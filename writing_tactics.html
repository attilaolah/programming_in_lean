
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=ascii" />
    <title>5. Writing Tactics &#8212; Programming in Lean 3.4.2 documentation</title>
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/language_data.js"></script>
    <link rel="shortcut icon" href="_static/favicon.ico"/>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="6. Writing Automation" href="writing_automation.html" />
    <link rel="prev" title="4. Monads" href="monads.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="writing-tactics">
<span id="id1"></span><h1>5. Writing Tactics<a class="headerlink" href="#writing-tactics" title="Permalink to this headline">&#182;</a></h1>
<div class="section" id="a-first-look-at-the-tactic-monad">
<h2>5.1. A First Look at the Tactic Monad<a class="headerlink" href="#a-first-look-at-the-tactic-monad" title="Permalink to this headline">&#182;</a></h2>
<p>The canonical way to invoke a tactic in Lean is to use the <code class="docutils literal notranslate"><span class="pre">by</span></code> keyword within a Lean expression. Suppose we write the following:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre>variables a b : Prop

example : a &#8594; b &#8594; a &#8743; b :=
by _
</pre></div>
</div>
<p>Lean expects something of type <code class="docutils literal notranslate"><span class="pre">tactic</span> <span class="pre">unit</span></code> to fill the underscore, where <code class="docutils literal notranslate"><span class="pre">tactic</span></code> refers to the tactic monad. When the elaborator processes this definition, it elaborates everything outside the <code class="docutils literal notranslate"><span class="pre">by</span></code> invocation first (in this case, just the statement of the theorem), and then calls on the Lean virtual machine to execute the tactic. When doing so, the virtual machine interprets any axiomatically declared <code class="docutils literal notranslate"><span class="pre">meta</span> <span class="pre">constant</span></code> as references to internal Lean functions that implement the functionality of the tactic monad.</p>
<p>The tactic monad can be thought of as a combination of a state monad (where the internal &#8220;state&#8221; as accessed and acted on by the <code class="docutils literal notranslate"><span class="pre">meta</span> <span class="pre">constant</span></code> primitives) and the option monad. Because it is a monad, we have the usual <code class="docutils literal notranslate"><span class="pre">do</span></code> notation. So, if <code class="docutils literal notranslate"><span class="pre">r</span></code>, <code class="docutils literal notranslate"><span class="pre">s</span></code>, and <code class="docutils literal notranslate"><span class="pre">t</span></code> are tactics, you should think of</p>
<div class="highlight-text notranslate"><div class="highlight"><pre>do a &#8592; r,
   b &#8592; s,
   t
</pre></div>
</div>
<p>as meaning &#8220;apply tactic <code class="docutils literal notranslate"><span class="pre">r</span></code> to the state, and store the return result in <code class="docutils literal notranslate"><span class="pre">a</span></code>; apply tactic <code class="docutils literal notranslate"><span class="pre">s</span></code> to the state, and store the return result in <code class="docutils literal notranslate"><span class="pre">b</span></code>; then, finally, apply tactic <code class="docutils literal notranslate"><span class="pre">t</span></code> to the state.&#8221; Moreover, any tactic can <em>fail</em>, which is analogous to a return value of <code class="docutils literal notranslate"><span class="pre">none</span></code> in the option monad. In the example above, if any of <code class="docutils literal notranslate"><span class="pre">r</span></code>, <code class="docutils literal notranslate"><span class="pre">s</span></code>, or <code class="docutils literal notranslate"><span class="pre">t</span></code> fail, then the compound expression has failed.</p>
<p>There is an additional, really interesting feature of the tactic monad: it is an <em>alternative</em> monad, in the sense described at the end of the last chapter. This is used to implement backtracking. If <code class="docutils literal notranslate"><span class="pre">s</span></code> and <code class="docutils literal notranslate"><span class="pre">t</span></code> are monads, the expression <code class="docutils literal notranslate"><span class="pre">s</span> <span class="pre">&lt;|&gt;</span> <span class="pre">t</span></code> can be understood as follows: &#8220;do <code class="docutils literal notranslate"><span class="pre">s</span></code>, and if that succeeds, return the corresponding return value; otherwise, undo any changes to the state that <code class="docutils literal notranslate"><span class="pre">s</span></code> may have produced, and do <code class="docutils literal notranslate"><span class="pre">t</span></code> instead.&#8221; This allows us to try <code class="docutils literal notranslate"><span class="pre">s</span></code> and, if it fails, go on to try <code class="docutils literal notranslate"><span class="pre">t</span></code> as though the first attempt never happened.</p>
<p>When the tactic expression after a <code class="docutils literal notranslate"><span class="pre">by</span></code> is invoked, the tactic wakes up and says &#8220;Whoa! I&#8217;m in a monad!&#8221; This is just a colorful way of saying that the virtual machine expects a function that acts on the tactic state in a certain way, and interprets primitive operations on the tactic state in terms of functions that are implemented internal to Lean. At any rate, when it wakes up, it can start to look around and assess its current state. The goal of this section is to give you a first look at of some of the things it can do there. Don&#8217;t worry if some of the expressions seem mysterious; they will be explained in the sections that follow.</p>
<p>One thing the tactic can do is print a message to the outside world:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=open%20tactic%0A%0Aexample%20(a%20b%20:%20Prop)%20:%20a%20%E2%86%92%20b%20%E2%86%92%20a%20%E2%88%A7%20b%20:=%0Aby%20do%20trace%20%22Hi,%20Mom!%22,%0A%20%20%20admit" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kn">open</span> <span class="n">tactic</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">&#8594;</span> <span class="n">b</span> <span class="bp">&#8594;</span> <span class="n">a</span> <span class="bp">&#8743;</span> <span class="n">b</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="k">do</span> <span class="n">trace</span> <span class="s2">&quot;Hi, Mom!&quot;</span><span class="o">,</span>
   <span class="n">admit</span>
</pre></div>
</div>
</div><p>When the file is executed, Lean issues an error message to the effect that the tactic has failed to fill the relevant placeholder, which is what it is supposed to do. But the <code class="docutils literal notranslate"><span class="pre">trace</span></code> message is printed during the execution, providing us with a glimpse of its inner workings. We can actually trace value of any type that Lean can coerce to a string output, and we will see that this includes a number of useful types. The <code class="docutils literal notranslate"><span class="pre">admit</span></code> tactic is a tactic version of <code class="docutils literal notranslate"><span class="pre">sorry</span></code>. Note that we use <code class="docutils literal notranslate"><span class="pre">open</span> <span class="pre">tactic</span></code> to open the <code class="docutils literal notranslate"><span class="pre">tactic</span></code> namespace and access the core tactic library. We will hide this line in the code snippets that follow.</p>
<p>Another thing we can do is trace the current tactic state:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=open%20tactic%0A%0A--%20BEGIN%0Aexample%20(a%20b%20:%20Prop)%20:%20a%20%E2%86%92%20b%20%E2%86%92%20a%20%E2%88%A7%20b%20:=%0Aby%20do%20trace%20%22Hi,%20Mom!%22,%0A%20%20%20%20%20%20trace_state,%0A%20%20%20%20%20%20admit%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kd">example</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">&#8594;</span> <span class="n">b</span> <span class="bp">&#8594;</span> <span class="n">a</span> <span class="bp">&#8743;</span> <span class="n">b</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="k">do</span> <span class="n">trace</span> <span class="s2">&quot;Hi, Mom!&quot;</span><span class="o">,</span>
      <span class="n">trace_state</span><span class="o">,</span>
      <span class="n">admit</span>
</pre></div>
</div>
</div><p>Now the output includes the list of <em>goals</em> that are active in the tactic state, each with a local context that includes the local variables and hypotheses. In this case there is only one:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre>Hi, Mom!
a b : Prop
&#8866; a &#8594; b &#8594; a &#8743; b
</pre></div>
</div>
<p>This points to an important fact: the internal, and somewhat mysterious, tactic state includes at least a list of goals. In fact, it includes much more: every tactic is invoked in a rich <em>environment</em> that includes all the objects and declarations that are present when the tactic is invoked, as well as notations, option declarations, and so on. In most cases, however, the list of goals is most directly relevant to the task at hand.</p>
<p>Let us dispense with the trace messages now, and start to prove the theorem by introducing the first two hypotheses.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre>example (a b : Prop) : a &#8594; b &#8594; a &#8743; b :=
by do eh1 &#8592; intro `h1,
      eh2 &#8592; intro `h2,
      skip
</pre></div>
</div>
<p>The backticks indicate that <code class="docutils literal notranslate"><span class="pre">h1</span></code> and <code class="docutils literal notranslate"><span class="pre">h2</span></code> are <em>names</em>; we will discuss these below. The tactic <code class="docutils literal notranslate"><span class="pre">skip</span></code> is a do-nothing tactic, simply included to ensure that the resulting expression has type <code class="docutils literal notranslate"><span class="pre">tactic</span> <span class="pre">unit</span></code>.</p>
<p>We can now do some looking around. The <code class="docutils literal notranslate"><span class="pre">meta_constant</span></code> called <code class="docutils literal notranslate"><span class="pre">target</span></code> has type <code class="docutils literal notranslate"><span class="pre">tactic</span> <span class="pre">expr</span></code>, and returns the type of the goal. The type <code class="docutils literal notranslate"><span class="pre">expr</span></code>, like <code class="docutils literal notranslate"><span class="pre">name</span></code>, will be discussed below; it is designed to reflect the internal representation of Lean expressions, so, roughly, via meta-programming glue, the <code class="docutils literal notranslate"><span class="pre">expr</span></code> type allows us to manipulate Lean expressions in Lean itself. In particular, we can ask the tactic to print the current goal:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=open%20tactic%0A%0A--%20BEGIN%0Aexample%20(a%20b%20:%20Prop)%20:%20a%20%E2%86%92%20b%20%E2%86%92%20a%20%E2%88%A7%20b%20:=%0Aby%20do%20eh1%20%E2%86%90%20intro%20%60h1,%0A%20%20%20%20%20%20eh2%20%E2%86%90%20intro%20%60h2,%0A%20%20%20%20%20%20target%20%3E%3E=%20trace,%0A%20%20%20%20%20%20admit%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kd">example</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">&#8594;</span> <span class="n">b</span> <span class="bp">&#8594;</span> <span class="n">a</span> <span class="bp">&#8743;</span> <span class="n">b</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="k">do</span> <span class="n">eh1</span> <span class="bp">&#8592;</span> <span class="n">intro</span> <span class="bp">`</span><span class="n">h1</span><span class="o">,</span>
      <span class="n">eh2</span> <span class="bp">&#8592;</span> <span class="n">intro</span> <span class="bp">`</span><span class="n">h2</span><span class="o">,</span>
      <span class="n">target</span> <span class="bp">&gt;&gt;=</span> <span class="n">trace</span><span class="o">,</span>
      <span class="n">admit</span>
</pre></div>
</div>
</div><p>In this case, the output is <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&#8743;</span> <span class="pre">b</span></code>, as we would expect. We can also ask the tactic to print the elements of the local context.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=open%20tactic%0A%0A--%20BEGIN%0Aexample%20(a%20b%20:%20Prop)%20:%20a%20%E2%86%92%20b%20%E2%86%92%20a%20%E2%88%A7%20b%20:=%0Aby%20do%20eh1%20%E2%86%90%20intro%20%60h1,%0A%20%20%20%20%20%20eh2%20%E2%86%90%20intro%20%60h2,%0A%20%20%20%20%20%20local_context%20%3E%3E=%20trace,%0A%20%20%20%20%20%20admit%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kd">example</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">&#8594;</span> <span class="n">b</span> <span class="bp">&#8594;</span> <span class="n">a</span> <span class="bp">&#8743;</span> <span class="n">b</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="k">do</span> <span class="n">eh1</span> <span class="bp">&#8592;</span> <span class="n">intro</span> <span class="bp">`</span><span class="n">h1</span><span class="o">,</span>
      <span class="n">eh2</span> <span class="bp">&#8592;</span> <span class="n">intro</span> <span class="bp">`</span><span class="n">h2</span><span class="o">,</span>
      <span class="n">local_context</span> <span class="bp">&gt;&gt;=</span> <span class="n">trace</span><span class="o">,</span>
      <span class="n">admit</span>
</pre></div>
</div>
</div><p>This yields the list <code class="docutils literal notranslate"><span class="pre">[a,</span> <span class="pre">b,</span> <span class="pre">h1,</span> <span class="pre">h2]</span></code>. We already happen to have representations of <code class="docutils literal notranslate"><span class="pre">h1</span></code> and <code class="docutils literal notranslate"><span class="pre">h2</span></code>, because they were returned by the <code class="docutils literal notranslate"><span class="pre">intro</span></code> tactic. But we can extract the other expressions in the local context given their names:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=open%20tactic%0A%0A--%20BEGIN%0Aexample%20(a%20b%20:%20Prop)%20:%20a%20%E2%86%92%20b%20%E2%86%92%20a%20%E2%88%A7%20b%20:=%0Aby%20do%20intro%20%60h1,%0A%20%20%20%20%20%20intro%20%60h2,%0A%20%20%20%20%20%20ea%20%E2%86%90%20get_local%20%60a,%0A%20%20%20%20%20%20eb%20%E2%86%90%20get_local%20%60b,%0A%20%20%20%20%20%20trace%20(to_string%20ea%20++%20%22,%20%22%20++%20to_string%20eb),%0A%20%20%20%20%20%20admit%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kd">example</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">&#8594;</span> <span class="n">b</span> <span class="bp">&#8594;</span> <span class="n">a</span> <span class="bp">&#8743;</span> <span class="n">b</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="k">do</span> <span class="n">intro</span> <span class="bp">`</span><span class="n">h1</span><span class="o">,</span>
      <span class="n">intro</span> <span class="bp">`</span><span class="n">h2</span><span class="o">,</span>
      <span class="n">ea</span> <span class="bp">&#8592;</span> <span class="n">get_local</span> <span class="bp">`</span><span class="n">a</span><span class="o">,</span>
      <span class="n">eb</span> <span class="bp">&#8592;</span> <span class="n">get_local</span> <span class="bp">`</span><span class="n">b</span><span class="o">,</span>
      <span class="n">trace</span> <span class="o">(</span><span class="n">to_string</span> <span class="n">ea</span> <span class="bp">++</span> <span class="s2">&quot;, &quot;</span> <span class="bp">++</span> <span class="n">to_string</span> <span class="n">eb</span><span class="o">),</span>
      <span class="n">admit</span>
</pre></div>
</div>
</div><p>Notice that <code class="docutils literal notranslate"><span class="pre">ea</span></code> and <code class="docutils literal notranslate"><span class="pre">eb</span></code> are different from <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code>; they have type <code class="docutils literal notranslate"><span class="pre">expr</span></code> rather than <code class="docutils literal notranslate"><span class="pre">Prop</span></code>. They are the internal representations of the latter expressions. At present, there is not much for us to do with these expressions other than print them out, so we will drop them for now.</p>
<p>In any case, to prove the goal, we can proceed to invoke any of the Lean&#8217;s standard tactics. For example, this will work:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=open%20tactic%0A%0A--%20BEGIN%0Aexample%20(a%20b%20:%20Prop)%20:%20a%20%E2%86%92%20b%20%E2%86%92%20a%20%E2%88%A7%20b%20:=%0Aby%20do%20intro%20%60h1,%0A%20%20%20%20%20%20intro%20%60h2,%0A%20%20%20%20%20%20split,%0A%20%20%20%20%20%20repeat%20assumption%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kd">example</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">&#8594;</span> <span class="n">b</span> <span class="bp">&#8594;</span> <span class="n">a</span> <span class="bp">&#8743;</span> <span class="n">b</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="k">do</span> <span class="n">intro</span> <span class="bp">`</span><span class="n">h1</span><span class="o">,</span>
      <span class="n">intro</span> <span class="bp">`</span><span class="n">h2</span><span class="o">,</span>
      <span class="n">split</span><span class="o">,</span>
      <span class="n">repeat</span> <span class="n">assumption</span>
</pre></div>
</div>
</div><p>We can also do it in a more hands-on way:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=open%20tactic%0A%0A--%20BEGIN%0Aexample%20(a%20b%20:%20Prop)%20:%20a%20%E2%86%92%20b%20%E2%86%92%20a%20%E2%88%A7%20b%20:=%0Aby%20do%20eh1%20%E2%86%90%20intro%20%60h1,%0A%20%20%20%20%20%20eh2%20%E2%86%90%20intro%20%60h2,%0A%20%20%20%20%20%20mk_const%20%60%60and.intro%20%3E%3E=%20apply,%0A%20%20%20%20%20%20exact%20eh1,%0A%20%20%20%20%20%20exact%20eh2%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kd">example</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">&#8594;</span> <span class="n">b</span> <span class="bp">&#8594;</span> <span class="n">a</span> <span class="bp">&#8743;</span> <span class="n">b</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="k">do</span> <span class="n">eh1</span> <span class="bp">&#8592;</span> <span class="n">intro</span> <span class="bp">`</span><span class="n">h1</span><span class="o">,</span>
      <span class="n">eh2</span> <span class="bp">&#8592;</span> <span class="n">intro</span> <span class="bp">`</span><span class="n">h2</span><span class="o">,</span>
      <span class="n">mk_const</span> <span class="bp">``</span><span class="n">and.intro</span> <span class="bp">&gt;&gt;=</span> <span class="n">apply</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">eh1</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">eh2</span>
</pre></div>
</div>
</div><p>The double-backticks will also be explained below, but the general idea is that the third line of the tactic builds an <code class="docutils literal notranslate"><span class="pre">expr</span></code> that reflects the <code class="docutils literal notranslate"><span class="pre">and.intro</span></code> declaration in the Lean environment, and applies it. The <code class="docutils literal notranslate"><span class="pre">applyc</span></code> tactic combines these two steps:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=open%20tactic%0A%0A--%20BEGIN%0Aexample%20(a%20b%20:%20Prop)%20:%20a%20%E2%86%92%20b%20%E2%86%92%20a%20%E2%88%A7%20b%20:=%0Aby%20do%20eh1%20%E2%86%90%20intro%20%60h1,%0A%20%20%20%20%20%20eh2%20%E2%86%90%20intro%20%60h2,%0A%20%20%20%20%20%20applyc%20%60%60and.intro,%0A%20%20%20%20%20%20exact%20eh1,%0A%20%20%20%20%20%20exact%20eh2%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kd">example</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">&#8594;</span> <span class="n">b</span> <span class="bp">&#8594;</span> <span class="n">a</span> <span class="bp">&#8743;</span> <span class="n">b</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="k">do</span> <span class="n">eh1</span> <span class="bp">&#8592;</span> <span class="n">intro</span> <span class="bp">`</span><span class="n">h1</span><span class="o">,</span>
      <span class="n">eh2</span> <span class="bp">&#8592;</span> <span class="n">intro</span> <span class="bp">`</span><span class="n">h2</span><span class="o">,</span>
      <span class="n">applyc</span> <span class="bp">``</span><span class="n">and.intro</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">eh1</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">eh2</span>
</pre></div>
</div>
</div><p>We can also finish the proof as follows:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=open%20tactic%0A%0A--%20BEGIN%0Aexample%20(a%20b%20:%20Prop)%20:%20a%20%E2%86%92%20b%20%E2%86%92%20a%20%E2%88%A7%20b%20:=%0Aby%20do%20eh1%20%E2%86%90%20intro%20%60h1,%0A%20%20%20%20%20%20eh2%20%E2%86%90%20intro%20%60h2,%0A%20%20%20%20%20%20e%20%E2%86%90%20to_expr%20%60%60%60(and.intro%20h1%20h2),%0A%20%20%20%20%20%20exact%20e%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kd">example</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">&#8594;</span> <span class="n">b</span> <span class="bp">&#8594;</span> <span class="n">a</span> <span class="bp">&#8743;</span> <span class="n">b</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="k">do</span> <span class="n">eh1</span> <span class="bp">&#8592;</span> <span class="n">intro</span> <span class="bp">`</span><span class="n">h1</span><span class="o">,</span>
      <span class="n">eh2</span> <span class="bp">&#8592;</span> <span class="n">intro</span> <span class="bp">`</span><span class="n">h2</span><span class="o">,</span>
      <span class="n">e</span> <span class="bp">&#8592;</span> <span class="n">to_expr</span> <span class="bp">```</span><span class="o">(</span><span class="n">and.intro</span> <span class="n">h1</span> <span class="n">h2</span><span class="o">),</span>
      <span class="n">exact</span> <span class="n">e</span>
</pre></div>
</div>
</div><p>Here, the construct <code class="docutils literal notranslate"><span class="pre">```(...)</span></code> is used to build a <em>pre-expression</em>, the tactic <code class="docutils literal notranslate"><span class="pre">to_expr</span></code> elaborates it and converts it to an expression, and the <code class="docutils literal notranslate"><span class="pre">exact</span></code> tactic applies it. In the next section, we will see even more variations on constructions like these, including tactics that would enable us to construct the expression <code class="docutils literal notranslate"><span class="pre">and.intro</span> <span class="pre">h1</span> <span class="pre">h2</span></code> more explicitly.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">do</span></code> block in this example has type <code class="docutils literal notranslate"><span class="pre">tactic</span> <span class="pre">unit</span></code>, and can be broken out as an independent tactic.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=open%20tactic%0A%0A--%20BEGIN%0Ameta%20def%20my_tactic%20:%20tactic%20unit%20:=%0Ado%20eh1%20%E2%86%90%20intro%20%60h1,%0A%20%20%20eh2%20%E2%86%90%20intro%20%60h2,%0A%20%20%20e%20%E2%86%90%20to_expr%20%60%60(and.intro%20%25%25eh1%20%25%25eh2),%0A%20%20%20exact%20e%0A%0Aexample%20(a%20b%20:%20Prop)%20:%20a%20%E2%86%92%20b%20%E2%86%92%20a%20%E2%88%A7%20b%20:=%0Aby%20my_tactic%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kd">meta</span> <span class="kd">def</span> <span class="n">my_tactic</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span>
<span class="k">do</span> <span class="n">eh1</span> <span class="bp">&#8592;</span> <span class="n">intro</span> <span class="bp">`</span><span class="n">h1</span><span class="o">,</span>
   <span class="n">eh2</span> <span class="bp">&#8592;</span> <span class="n">intro</span> <span class="bp">`</span><span class="n">h2</span><span class="o">,</span>
   <span class="n">e</span> <span class="bp">&#8592;</span> <span class="n">to_expr</span> <span class="bp">``</span><span class="o">(</span><span class="n">and.intro</span> <span class="bp">%%</span><span class="n">eh1</span> <span class="bp">%%</span><span class="n">eh2</span><span class="o">),</span>
   <span class="n">exact</span> <span class="n">e</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">&#8594;</span> <span class="n">b</span> <span class="bp">&#8594;</span> <span class="n">a</span> <span class="bp">&#8743;</span> <span class="n">b</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">my_tactic</span>
</pre></div>
</div>
</div><p>Of course, <code class="docutils literal notranslate"><span class="pre">my_tactic</span></code> is not a very exciting tactic; we designed it to prove one particular theorem, and it will only work on examples that have the very same shape. But we can write more intelligent tactics that inspect the goal, the local hypotheses, and the environment, and then do more useful things. The mechanism is exactly the same: we construct an expression of type <code class="docutils literal notranslate"><span class="pre">tactic</span> <span class="pre">unit</span></code>, and ask the virtual machine to execute it at elaboration time to solve the goal at hand.</p>
</div>
<div class="section" id="names-and-expressions">
<h2>5.2. Names and Expressions<a class="headerlink" href="#names-and-expressions" title="Permalink to this headline">&#182;</a></h2>
<p>Suppose we write an ordinary tactic proof in Lean:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=example%20(a%20b%20:%20Prop)%20(h%20:%20a%20%E2%88%A7%20b)%20:%20b%20%E2%88%A7%20a%20:=%0Abegin%0A%20%20split,%0A%20%20exact%20and.right%20h,%0A%20%20exact%20and.left%20h%0Aend" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kd">example</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">&#8743;</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">&#8743;</span> <span class="n">a</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">and.right</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">and.left</span> <span class="n">h</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>This way of writing the tactic proof suggests that the <code class="docutils literal notranslate"><span class="pre">h</span></code> in the tactic block refers to the expression <code class="docutils literal notranslate"><span class="pre">h</span> <span class="pre">:</span> <span class="pre">a</span> <span class="pre">&#8743;</span> <span class="pre">b</span></code> in the list of hypotheses. But this is an illusion; what <code class="docutils literal notranslate"><span class="pre">h</span></code> <em>really</em> refers to is the first hypothesis <em>named</em> <code class="docutils literal notranslate"><span class="pre">h</span></code> that is in the local context of the goal in the state when the tactic is executed. This is made clear, for example, by the fact that earlier lines in the proof can change the name of the hypothesis:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=example%20(a%20b%20:%20Prop)%20(h%20:%20a%20%E2%88%A7%20b)%20:%20b%20%E2%88%A7%20a%20:=%0Abegin%0A%20%20revert%20h,%0A%20%20intro%20h',%0A%20%20split,%0A%20%20exact%20and.right%20h',%0A%20%20exact%20and.left%20h'%0Aend" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kd">example</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">&#8743;</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">&#8743;</span> <span class="n">a</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">revert</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">intro</span> <span class="n">h&#39;</span><span class="o">,</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">and.right</span> <span class="n">h&#39;</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">and.left</span> <span class="n">h&#39;</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>Now writing <code class="docutils literal notranslate"><span class="pre">exact</span> <span class="pre">and.right</span> <span class="pre">h</span></code> would make no sense. We could, alternatively, contrive to make <code class="docutils literal notranslate"><span class="pre">h</span></code> denote something different from the original hypothesis. This often happens with the <code class="docutils literal notranslate"><span class="pre">cases</span></code> and <code class="docutils literal notranslate"><span class="pre">induction</span></code> tactics, which revert hypotheses, peform an action, and then reintroduce new hypotheses with the same names.</p>
<p>Metaprogramming in Lean requires us to be mindful of and explicit about the distinction between expressions in the current environment, like <code class="docutils literal notranslate"><span class="pre">h</span> <span class="pre">:</span> <span class="pre">a</span> <span class="pre">&#8743;</span> <span class="pre">b</span></code> in the hypothesis of the example, and the Lean objects that we use to act on the tactic state, such as the name &#8220;h&#8221; or an object of type <code class="docutils literal notranslate"><span class="pre">expr</span></code>. Without using the <code class="docutils literal notranslate"><span class="pre">begin...end</span></code> front end, we can construct the proof as follows:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=open%20tactic%0A%0A--%20BEGIN%0Aexample%20(a%20b%20:%20Prop)%20(h%20:%20a%20%E2%88%A7%20b)%20:%20b%20%E2%88%A7%20a%20:=%0Aby%20do%20split,%0A%20%20%20to_expr%20%60%60%60(and.right%20h)%20%3E%3E=%20exact,%0A%20%20%20to_expr%20%60%60%60(and.left%20h)%20%3E%3E=%20exact%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kd">example</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">&#8743;</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">&#8743;</span> <span class="n">a</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="k">do</span> <span class="n">split</span><span class="o">,</span>
   <span class="n">to_expr</span> <span class="bp">```</span><span class="o">(</span><span class="n">and.right</span> <span class="n">h</span><span class="o">)</span> <span class="bp">&gt;&gt;=</span> <span class="n">exact</span><span class="o">,</span>
   <span class="n">to_expr</span> <span class="bp">```</span><span class="o">(</span><span class="n">and.left</span> <span class="n">h</span><span class="o">)</span> <span class="bp">&gt;&gt;=</span> <span class="n">exact</span>
</pre></div>
</div>
</div><p>This tells Lean to elaborate the expressions <code class="docutils literal notranslate"><span class="pre">and.right</span> <span class="pre">h</span></code> and <code class="docutils literal notranslate"><span class="pre">and.left</span> <span class="pre">h</span></code> in the context of the current goal, and then apply them. The <code class="docutils literal notranslate"><span class="pre">begin...end</span></code> construct is essentially a front end that interprets the proof above in these terms.</p>
<p>To understand what is going on in situations like this, it is important to know that Lean&#8217;s metaprogramming framework provides three distinct Lean types that are relevant to constructing syntactic expressions:</p>
<ul class="simple">
<li>the type <code class="docutils literal notranslate"><span class="pre">name</span></code>, representing <em>hierarchical names</em></li>
<li>the type <code class="docutils literal notranslate"><span class="pre">expr</span></code>, representing <em>expressions</em></li>
<li>the type <code class="docutils literal notranslate"><span class="pre">pexpr</span></code>, representing <em>pre-expressions</em></li>
</ul>
<p>Let us consider each one of them, in turn.</p>
<p>Hierarchical names are denoted in ordinary .lean files with expressions like <code class="docutils literal notranslate"><span class="pre">foo.bar.baz</span></code> or <code class="docutils literal notranslate"><span class="pre">nat.mul_comm</span></code>. They are used as identifiers that reference defined constants in Lean, but also for local variables, attributes, and other objects. Their Lean representations are defined in <code class="docutils literal notranslate"><span class="pre">init/meta/name.lean</span></code>, together with some operations that can be performed on them. But for many purposes we can be oblivious to the details. Whenever we type an expression that begins with a backtick that is not followed by an open parenthesis, Lean&#8217;s parser translates this to the construction of the associated name. In other words, <code class="docutils literal notranslate"><span class="pre">`nat.mul_comm</span></code> is simply notation for the compound name with components <code class="docutils literal notranslate"><span class="pre">nat</span></code> and <code class="docutils literal notranslate"><span class="pre">mul_comm</span></code>.</p>
<p>When metaprogramming, we often use names to refer to definitions and theorems in the Lean environment. In situations like that, it is easy to make mistakes. In the example below, the tactic definition is accepted, but its application fails:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=open%20tactic%0A%0Anamespace%20foo%0A%0Atheorem%20bar%20:%20true%20:=%20trivial%0A%0Ameta%20def%20my_tac%20:%20tactic%20unit%20:=%0Amk_const%20%60bar%20%3E%3E=%20exact%0A%0A--%20example%20:%20true%20:=%20by%20my_tac%20--%20fails%0A%0Aend%20foo" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kn">open</span> <span class="n">tactic</span>

<span class="kn">namespace</span> <span class="n">foo</span>

<span class="kd">theorem</span> <span class="n">bar</span> <span class="o">:</span> <span class="n">true</span> <span class="o">:=</span> <span class="n">trivial</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">my_tac</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span>
<span class="n">mk_const</span> <span class="bp">`</span><span class="n">bar</span> <span class="bp">&gt;&gt;=</span> <span class="n">exact</span>

<span class="c1">-- example : true := by my_tac -- fails</span>

<span class="kd">end</span> <span class="n">foo</span>
</pre></div>
</div>
</div><p>The problem is that the proper name for the theorem is <code class="docutils literal notranslate"><span class="pre">foo.bar</span></code> rather than <code class="docutils literal notranslate"><span class="pre">bar</span></code>; if we replace <code class="docutils literal notranslate"><span class="pre">`bar</span></code> by <code class="docutils literal notranslate"><span class="pre">`foo.bar</span></code>, the example is accepted. The <code class="docutils literal notranslate"><span class="pre">mk_const</span></code> tactic takes an arbitrary name and attempts to resolve it when the tactic is invoked, so there is no error in the definition of the tactic. The error is rather that when we wrote <code class="docutils literal notranslate"><span class="pre">`bar</span></code> we had in mind a particular theorem in the environment at the time, but we did not identify it correctly.</p>
<p>For situations like these, Lean provides double-backtick notation. The following example succeeds:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=open%20tactic%0A%0Anamespace%20foo%0A%0Atheorem%20bar%20:%20true%20:=%20trivial%0A%0Ameta%20def%20my_tac%20:%20tactic%20unit%20:=%0Amk_const%20%60%60bar%20%3E%3E=%20exact%0A%0Aexample%20:%20true%20:=%20by%20my_tac%20--%20fails%0A%0Aend%20foo" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kn">open</span> <span class="n">tactic</span>

<span class="kn">namespace</span> <span class="n">foo</span>

<span class="kd">theorem</span> <span class="n">bar</span> <span class="o">:</span> <span class="n">true</span> <span class="o">:=</span> <span class="n">trivial</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">my_tac</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span>
<span class="n">mk_const</span> <span class="bp">``</span><span class="n">bar</span> <span class="bp">&gt;&gt;=</span> <span class="n">exact</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">true</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">my_tac</span> <span class="c1">-- fails</span>

<span class="kd">end</span> <span class="n">foo</span>
</pre></div>
</div>
</div><p>It also succeeds if we replace <code class="docutils literal notranslate"><span class="pre">``bar</span></code> by <code class="docutils literal notranslate"><span class="pre">``foo.bar</span></code>. The double-backtick asks the parser to resolve the expression with the name of an object in the environment <em>at parse time</em>, and insert the relevant name. This has two advantages:</p>
<ul class="simple">
<li>if there is no such object in the environment at the time, the parser raises an error; and</li>
<li>assuming it does find the relevant object in the environment, it inserts the full name of the object, meaning we can use abbreviations that make sense in the context where we are writing the tactic.</li>
</ul>
<p>As a result, it is a good idea to use double-backticks whenever you want to refer to an existing definition or theorem.</p>
<p>When writing tactics, it is often necessary to generate a fresh name. You can use <code class="docutils literal notranslate"><span class="pre">mk_fresh_name</span></code> for that:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=open%20tactic%0A%0A--%20BEGIN%0Aexample%20(a%20:%20Prop)%20:%20a%20%E2%86%92%20a%20:=%0Aby%20do%20n%20%E2%86%90%20mk_fresh_name,%0A%20%20%20%20%20%20intro%20n,%0A%20%20%20%20%20%20hyp%20%E2%86%90%20get_local%20n,%0A%20%20%20%20%20%20exact%20hyp%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kd">example</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">&#8594;</span> <span class="n">a</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="k">do</span> <span class="n">n</span> <span class="bp">&#8592;</span> <span class="n">mk_fresh_name</span><span class="o">,</span>
      <span class="n">intro</span> <span class="n">n</span><span class="o">,</span>
      <span class="n">hyp</span> <span class="bp">&#8592;</span> <span class="n">get_local</span> <span class="n">n</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">hyp</span>
</pre></div>
</div>
</div><p>A variant, <code class="docutils literal notranslate"><span class="pre">get_unused_name</span></code>, lets you suggest a name. If the name is in use, Lean will append a numeral to avoid duplication.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=open%20tactic%0A%0A--%20BEGIN%0Aexample%20(a%20:%20Prop)%20:%20a%20%E2%86%92%20a%20:=%0Aby%20do%20n%20%E2%86%90%20get_unused_name%20%22h%22,%0A%20%20%20%20%20%20intro%20n,%0A%20%20%20%20%20%20hyp%20%E2%86%90%20get_local%20n,%0A%20%20%20%20%20%20exact%20hyp%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kd">example</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">&#8594;</span> <span class="n">a</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="k">do</span> <span class="n">n</span> <span class="bp">&#8592;</span> <span class="n">get_unused_name</span> <span class="s2">&quot;h&quot;</span><span class="o">,</span>
      <span class="n">intro</span> <span class="n">n</span><span class="o">,</span>
      <span class="n">hyp</span> <span class="bp">&#8592;</span> <span class="n">get_local</span> <span class="n">n</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">hyp</span>
</pre></div>
</div>
</div><p>The type <code class="docutils literal notranslate"><span class="pre">expr</span></code> reflects the internal representation of Lean expressions. It is defined inductively in the file <code class="docutils literal notranslate"><span class="pre">expr.lean</span></code>, but when evaluating expressions that involve terms of type <code class="docutils literal notranslate"><span class="pre">expr</span></code>, the virtual machine uses the internal C++ representations, so each constructor and the eliminator for the type are translated to the corresponding C++ functions. Expressions include the sorts <code class="docutils literal notranslate"><span class="pre">Prop</span></code>, <code class="docutils literal notranslate"><span class="pre">Type&#8321;</span></code>, <code class="docutils literal notranslate"><span class="pre">Type&#8322;</span></code>, &#8230;, constants of each type, applications, lambdas, Pi types, and let definitions. The also include de Bruijn indices (with constructor <code class="docutils literal notranslate"><span class="pre">var</span></code>), metavariables, local constants, and macros.</p>
<p>The whole purpose of tactic mode is to construct expressions, and so this data type is fundamental. We have already seen that the <code class="docutils literal notranslate"><span class="pre">target</span></code> tactic returns the current goal, which is an expression, and that <code class="docutils literal notranslate"><span class="pre">local_context</span></code> returns the list of hypotheses that can be used to solve the current goal, that is, a list of expressions.</p>
<p>Returning to the example at the start of this section, let us consider ways of constructing the expressions <code class="docutils literal notranslate"><span class="pre">and.left</span> <span class="pre">h</span></code> and <code class="docutils literal notranslate"><span class="pre">and.right</span> <span class="pre">h</span></code> more explicitly. The following example uses the <code class="docutils literal notranslate"><span class="pre">mk_mapp</span></code> tactic.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=open%20tactic%0A%0A--%20BEGIN%0Aexample%20(a%20b%20:%20Prop)%20(h%20:%20a%20%E2%88%A7%20b)%20:%20b%20%E2%88%A7%20a%20:=%0Aby%20do%20split,%0A%20%20%20eh%20%E2%86%90%20get_local%20%60h,%0A%20%20%20mk_mapp%20%60%60and.right%20%5Bnone,%20none,%20some%20eh%5D%20%3E%3E=%20exact,%0A%20%20%20mk_mapp%20%60%60and.left%20%5Bnone,%20none,%20some%20eh%5D%20%3E%3E=%20exact%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kd">example</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">&#8743;</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">&#8743;</span> <span class="n">a</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="k">do</span> <span class="n">split</span><span class="o">,</span>
   <span class="n">eh</span> <span class="bp">&#8592;</span> <span class="n">get_local</span> <span class="bp">`</span><span class="n">h</span><span class="o">,</span>
   <span class="n">mk_mapp</span> <span class="bp">``</span><span class="n">and.right</span> <span class="o">[</span><span class="n">none</span><span class="o">,</span> <span class="n">none</span><span class="o">,</span> <span class="n">some</span> <span class="n">eh</span><span class="o">]</span> <span class="bp">&gt;&gt;=</span> <span class="n">exact</span><span class="o">,</span>
   <span class="n">mk_mapp</span> <span class="bp">``</span><span class="n">and.left</span> <span class="o">[</span><span class="n">none</span><span class="o">,</span> <span class="n">none</span><span class="o">,</span> <span class="n">some</span> <span class="n">eh</span><span class="o">]</span> <span class="bp">&gt;&gt;=</span> <span class="n">exact</span>
</pre></div>
</div>
</div><p>In this example, the invocations of <code class="docutils literal notranslate"><span class="pre">mk_mapp</span></code> retrieve the definition of <code class="docutils literal notranslate"><span class="pre">and.right</span></code> and <code class="docutils literal notranslate"><span class="pre">and.left</span></code>, respectively. It makes no difference whether the arguments to those theorems have been marked implicit or explicit; <code class="docutils literal notranslate"><span class="pre">mk_mapp</span></code> ignores those annotations, and simply applies that theorem to all the arguments in the subsequent list. Thus the first argument to <code class="docutils literal notranslate"><span class="pre">mk_mapp</span></code> is a name, while the second argument has type <code class="docutils literal notranslate"><span class="pre">list</span> <span class="pre">(option</span> <span class="pre">expr)</span></code>. Each <code class="docutils literal notranslate"><span class="pre">none</span></code> entry in the list tells <code class="docutils literal notranslate"><span class="pre">mk_mapp</span></code> to treat that argument as implicit and infer it using type inference. In contrast, an entry of the form <code class="docutils literal notranslate"><span class="pre">some</span> <span class="pre">t</span></code> specifies <code class="docutils literal notranslate"><span class="pre">t</span></code> as the corresponding argument.</p>
<p>The tactic <code class="docutils literal notranslate"><span class="pre">mk_app</span></code> is an even more rudimentary application builder. It takes the name of the operator, followed by a complete list of its arguments.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=open%20tactic%0A%0A--%20BEGIN%0Aexample%20(a%20b%20:%20Prop)%20(h%20:%20a%20%E2%88%A7%20b)%20:%20b%20%E2%88%A7%20a%20:=%0Aby%20do%20split,%0A%20%20%20%20%20%20ea%20%E2%86%90%20get_local%20%60a,%0A%20%20%20%20%20%20eb%20%E2%86%90%20get_local%20%60b,%0A%20%20%20%20%20%20eh%20%E2%86%90%20get_local%20%60h,%0A%20%20%20%20%20%20mk_app%20%60%60and.right%20%5Bea,%20eb,%20eh%5D%20%3E%3E=%20exact,%0A%20%20%20%20%20%20mk_app%20%60%60and.left%20%5Bea,%20eb,%20eh%5D%20%3E%3E=%20exact%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kd">example</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">&#8743;</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">&#8743;</span> <span class="n">a</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="k">do</span> <span class="n">split</span><span class="o">,</span>
      <span class="n">ea</span> <span class="bp">&#8592;</span> <span class="n">get_local</span> <span class="bp">`</span><span class="n">a</span><span class="o">,</span>
      <span class="n">eb</span> <span class="bp">&#8592;</span> <span class="n">get_local</span> <span class="bp">`</span><span class="n">b</span><span class="o">,</span>
      <span class="n">eh</span> <span class="bp">&#8592;</span> <span class="n">get_local</span> <span class="bp">`</span><span class="n">h</span><span class="o">,</span>
      <span class="n">mk_app</span> <span class="bp">``</span><span class="n">and.right</span> <span class="o">[</span><span class="n">ea</span><span class="o">,</span> <span class="n">eb</span><span class="o">,</span> <span class="n">eh</span><span class="o">]</span> <span class="bp">&gt;&gt;=</span> <span class="n">exact</span><span class="o">,</span>
      <span class="n">mk_app</span> <span class="bp">``</span><span class="n">and.left</span> <span class="o">[</span><span class="n">ea</span><span class="o">,</span> <span class="n">eb</span><span class="o">,</span> <span class="n">eh</span><span class="o">]</span> <span class="bp">&gt;&gt;=</span> <span class="n">exact</span>
</pre></div>
</div>
</div><p>You can send less than the full list of arguments to <code class="docutils literal notranslate"><span class="pre">mk_app</span></code>, but the arguments you send are assumed to be the <em>final</em> arguments, with the earlier ones made implicit. Thus, in the example above, we could send instead <code class="docutils literal notranslate"><span class="pre">[eb,</span> <span class="pre">eh]</span></code> or simply <code class="docutils literal notranslate"><span class="pre">[eh]</span></code>, because the earlier arguments can be inferred from these.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=open%20tactic%0A%0A--%20BEGIN%0Aexample%20(a%20b%20:%20Prop)%20(h%20:%20a%20%E2%88%A7%20b)%20:%20b%20%E2%88%A7%20a%20:=%0Aby%20do%20split,%0A%20%20%20%20%20%20eh%20%E2%86%90%20get_local%20%60h,%0A%20%20%20%20%20%20mk_app%20%60%60and.right%20%5Beh%5D%20%3E%3E=%20exact,%0A%20%20%20%20%20%20mk_app%20%60%60and.left%20%5Beh%5D%20%3E%3E=%20exact%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kd">example</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">&#8743;</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">&#8743;</span> <span class="n">a</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="k">do</span> <span class="n">split</span><span class="o">,</span>
      <span class="n">eh</span> <span class="bp">&#8592;</span> <span class="n">get_local</span> <span class="bp">`</span><span class="n">h</span><span class="o">,</span>
      <span class="n">mk_app</span> <span class="bp">``</span><span class="n">and.right</span> <span class="o">[</span><span class="n">eh</span><span class="o">]</span> <span class="bp">&gt;&gt;=</span> <span class="n">exact</span><span class="o">,</span>
      <span class="n">mk_app</span> <span class="bp">``</span><span class="n">and.left</span> <span class="o">[</span><span class="n">eh</span><span class="o">]</span> <span class="bp">&gt;&gt;=</span> <span class="n">exact</span>
</pre></div>
</div>
</div><p>Finally, as indicated in the last section, you can also use <code class="docutils literal notranslate"><span class="pre">mk_const</span></code> to construct a constant expression from the corresponding name:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=open%20tactic%0A%0A--%20BEGIN%0Aexample%20(a%20b%20:%20Prop)%20(h%20:%20a%20%E2%88%A7%20b)%20:%20b%20%E2%88%A7%20a%20:=%0Aby%20do%20split,%0A%20%20%20%20%20%20eh%20%E2%86%90%20get_local%20%60h,%0A%20%20%20%20%20%20mk_const%20%60%60and.right%20%3E%3E=%20apply,%0A%20%20%20%20%20%20exact%20eh,%0A%20%20%20%20%20%20mk_const%20%60%60and.left%20%3E%3E=%20apply,%0A%20%20%20%20%20%20exact%20eh%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kd">example</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">&#8743;</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">&#8743;</span> <span class="n">a</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="k">do</span> <span class="n">split</span><span class="o">,</span>
      <span class="n">eh</span> <span class="bp">&#8592;</span> <span class="n">get_local</span> <span class="bp">`</span><span class="n">h</span><span class="o">,</span>
      <span class="n">mk_const</span> <span class="bp">``</span><span class="n">and.right</span> <span class="bp">&gt;&gt;=</span> <span class="n">apply</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">eh</span><span class="o">,</span>
      <span class="n">mk_const</span> <span class="bp">``</span><span class="n">and.left</span> <span class="bp">&gt;&gt;=</span> <span class="n">apply</span><span class="o">,</span>
      <span class="n">exact</span> <span class="n">eh</span>
</pre></div>
</div>
</div><p>We have also seen above that it is possible to use <code class="docutils literal notranslate"><span class="pre">to_expr</span></code> to elaborate expressions at executation time, in the context of the current goal.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre>open tactic

-- BEGIN
example (a b : Prop) (h : a &#8743; b) : b &#8743; a :=
by do split,
   to_expr ```(and.right h) &gt;&gt;= exact,
   to_expr ```(and.left h) &gt;&gt;= exact
-- END
</pre></div>
</div>
<p>Here, the expressions <code class="docutils literal notranslate"><span class="pre">```(and.right</span> <span class="pre">h)</span></code> and <code class="docutils literal notranslate"><span class="pre">```(and.left</span> <span class="pre">h)</span></code> are pre-expressions, that is, objects of type <code class="docutils literal notranslate"><span class="pre">pexpr</span></code>. The interface to <code class="docutils literal notranslate"><span class="pre">pexpr</span></code> can be found in the file <code class="docutils literal notranslate"><span class="pre">pexpr.lean</span></code>, but the type is largely opaque from within Lean. The canonical use is given by the example above: when Lean&#8217;s parser encounters an expression of the form <code class="docutils literal notranslate"><span class="pre">```(...)</span></code>, it constructs the corresponding <code class="docutils literal notranslate"><span class="pre">pexpr</span></code>, which is simply an internal representation of the unelaborated term. The <code class="docutils literal notranslate"><span class="pre">to_expr</span></code> tactic then sends that object to the elaborator when the tactic is executed.</p>
<p>Note that the backtick is used in two distinct ways: an expression of the form <code class="docutils literal notranslate"><span class="pre">`n</span></code>, without the parentheses, denotes a <code class="docutils literal notranslate"><span class="pre">name</span></code>, whereas an expression of the form <code class="docutils literal notranslate"><span class="pre">`(...)</span></code>, with parentheses, denotes a <code class="docutils literal notranslate"><span class="pre">pexpr</span></code>. Though this may be confusing at first, it is easy to get used to the distinction, and the notation is quite convenient.</p>
<p>Lean&#8217;s pre-expression mechanism also supports the use of <em>anti-quotation</em>, which allows a tactic to tell the elaborator to insert an expression into a pre-expression at runtime. Returning to the example above, suppose we are in a situation where instead of the name <code class="docutils literal notranslate"><span class="pre">h</span></code>, we have the corresponding <em>expression</em>, <code class="docutils literal notranslate"><span class="pre">eh</span></code>, and want to use that to construct the term. We can insert it into the pre-expression by preceding it with a double-percent sign:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=open%20tactic%0A%0A--%20BEGIN%0Aexample%20(a%20b%20:%20Prop)%20(h%20:%20a%20%E2%88%A7%20b)%20:%20b%20%E2%88%A7%20a%20:=%0Aby%20do%20split,%0A%20%20%20eh%20%E2%86%90%20get_local%20%60h,%0A%20%20%20to_expr%20%60%60(and.right%20%25%25eh)%20%3E%3E=%20exact,%0A%20%20%20to_expr%20%60%60(and.left%20%25%25eh)%20%3E%3E=%20exact%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kd">example</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">&#8743;</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">&#8743;</span> <span class="n">a</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="k">do</span> <span class="n">split</span><span class="o">,</span>
   <span class="n">eh</span> <span class="bp">&#8592;</span> <span class="n">get_local</span> <span class="bp">`</span><span class="n">h</span><span class="o">,</span>
   <span class="n">to_expr</span> <span class="bp">``</span><span class="o">(</span><span class="n">and.right</span> <span class="bp">%%</span><span class="n">eh</span><span class="o">)</span> <span class="bp">&gt;&gt;=</span> <span class="n">exact</span><span class="o">,</span>
   <span class="n">to_expr</span> <span class="bp">``</span><span class="o">(</span><span class="n">and.left</span> <span class="bp">%%</span><span class="n">eh</span><span class="o">)</span> <span class="bp">&gt;&gt;=</span> <span class="n">exact</span>
</pre></div>
</div>
</div><p>When the tactic is executed, Lean elaborates the pre-expressions given by <code class="docutils literal notranslate"><span class="pre">``(...)</span></code>, with the expression <code class="docutils literal notranslate"><span class="pre">eh</span></code> inserted in the right place. The difference between <code class="docutils literal notranslate"><span class="pre">``(...)</span></code> and <code class="docutils literal notranslate"><span class="pre">```(...)</span></code> is that the first resolves the names contained in the expression when the tactic is defined, whereas the second resolves them when the tactic is executed. Since the only name occurring in <code class="docutils literal notranslate"><span class="pre">and.left</span> <span class="pre">%%eh</span></code> is <code class="docutils literal notranslate"><span class="pre">and.left</span></code>, it is better to resolve it right away. However, in the expression <code class="docutils literal notranslate"><span class="pre">and.right</span> <span class="pre">h</span></code> above, <code class="docutils literal notranslate"><span class="pre">h</span></code> only comes into existence when the tactic is executed, and so we need to use the triple backtick.</p>
<p>Finally, Lean can handle pattern matching on pre-expressions. To do so, use a single backtick, and use antiquotations to introduce variables in the patterns. The following tactic retrieves the goal, and takes action depending on its form.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=open%20tactic%0A%0A--%20BEGIN%0Ameta%20def%20do_something%20:%20tactic%20unit%20:=%0Ado%20t%20%E2%86%90%20target,%0A%20%20%20match%20t%20with%0A%20%20%20%7C%20%60(%25%25a%20%E2%88%A7%20%25%25b)%20:=%20split%20%3E%3E%20skip%0A%20%20%20%7C%20%60(%25%25a%20%E2%86%92%20%25%25b)%20:=%20do%20h%20%E2%86%90%20get_unused_name%20%22h%22,%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20intro%20h,%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20skip%0A%20%20%20%7C%20_%20%20%20%20%20%20%20%20%20%20%20%20:=%20try%20assumption%0A%20%20%20end%0A%0Aexample%20(a%20b%20c%20:%20Prop)%20:%20a%20%E2%86%92%20b%20%E2%86%92%20a%20%E2%86%92%20a%20%E2%88%A7%20b%20:=%0Abegin%0Ado_something,%20do_something,%20do_something,%20do_something,%20do_something,%20do_something%0Aend%0A%0Aexample%20(a%20b%20c%20:%20Prop)%20:%20a%20%E2%86%92%20b%20%E2%86%92%20a%20%E2%86%92%20a%20%E2%88%A7%20b%20:=%0Abegin%0Ado_something,%20do_something,%20do_something,%20do_something,%20assumption,%20assumption%0Aend%0A%0Aexample%20(a%20b%20c%20:%20Prop)%20:%20a%20%E2%86%92%20b%20%E2%86%92%20a%20%E2%86%92%20a%20%E2%88%A7%20b%20:=%0Aby%20repeat%20%7B%20do_something%20%7D%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kd">meta</span> <span class="kd">def</span> <span class="n">do_something</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span>
<span class="k">do</span> <span class="n">t</span> <span class="bp">&#8592;</span> <span class="n">target</span><span class="o">,</span>
   <span class="k">match</span> <span class="n">t</span> <span class="k">with</span>
   <span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="bp">%%</span><span class="n">a</span> <span class="bp">&#8743;</span> <span class="bp">%%</span><span class="n">b</span><span class="o">)</span> <span class="o">:=</span> <span class="n">split</span> <span class="bp">&gt;&gt;</span> <span class="n">skip</span>
   <span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="bp">%%</span><span class="n">a</span> <span class="bp">&#8594;</span> <span class="bp">%%</span><span class="n">b</span><span class="o">)</span> <span class="o">:=</span> <span class="k">do</span> <span class="n">h</span> <span class="bp">&#8592;</span> <span class="n">get_unused_name</span> <span class="s2">&quot;h&quot;</span><span class="o">,</span>
                        <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
                        <span class="n">skip</span>
   <span class="bp">|</span> <span class="n">_</span>            <span class="o">:=</span> <span class="n">try</span> <span class="n">assumption</span>
   <span class="kd">end</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">&#8594;</span> <span class="n">b</span> <span class="bp">&#8594;</span> <span class="n">a</span> <span class="bp">&#8594;</span> <span class="n">a</span> <span class="bp">&#8743;</span> <span class="n">b</span> <span class="o">:=</span>
<span class="kd">begin</span>
<span class="n">do_something</span><span class="o">,</span> <span class="n">do_something</span><span class="o">,</span> <span class="n">do_something</span><span class="o">,</span> <span class="n">do_something</span><span class="o">,</span> <span class="n">do_something</span><span class="o">,</span> <span class="n">do_something</span>
<span class="kd">end</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">&#8594;</span> <span class="n">b</span> <span class="bp">&#8594;</span> <span class="n">a</span> <span class="bp">&#8594;</span> <span class="n">a</span> <span class="bp">&#8743;</span> <span class="n">b</span> <span class="o">:=</span>
<span class="kd">begin</span>
<span class="n">do_something</span><span class="o">,</span> <span class="n">do_something</span><span class="o">,</span> <span class="n">do_something</span><span class="o">,</span> <span class="n">do_something</span><span class="o">,</span> <span class="n">assumption</span><span class="o">,</span> <span class="n">assumption</span>
<span class="kd">end</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">&#8594;</span> <span class="n">b</span> <span class="bp">&#8594;</span> <span class="n">a</span> <span class="bp">&#8594;</span> <span class="n">a</span> <span class="bp">&#8743;</span> <span class="n">b</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">repeat</span> <span class="o">{</span> <span class="n">do_something</span> <span class="o">}</span>
</pre></div>
</div>
</div></div>
<div class="section" id="examples">
<h2>5.3. Examples<a class="headerlink" href="#examples" title="Permalink to this headline">&#182;</a></h2>
<p>When it comes to writing tactics, you have all the computable entities of Lean&#8217;s standard library at your disposal, including lists, natural numbers, strings, product types, and so on. This makes the tactic monad a powerful mechanism for writing metaprograms. Some of Lean&#8217;s most basic tactics are implemented internally in C++, but many of them are defined from these in Lean itself.</p>
<p>The entry point for the tactic library is the file <code class="docutils literal notranslate"><span class="pre">init/meta/tactic.lean</span></code>, where you can find the details of the interface, and see a number of basic tactics implemented in Lean. For example, here is the definition of the <code class="docutils literal notranslate"><span class="pre">assumption</span></code> tactic:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=open%20tactic%0Anamespace%20hidden%0A%0A--%20BEGIN%0Ameta%20def%20find_same_type%20:%20expr%20%E2%86%92%20list%20expr%20%E2%86%92%20tactic%20expr%0A%7C%20e%20%5B%5D%20%20%20%20%20%20%20%20%20:=%20failed%0A%7C%20e%20(h%20::%20hs)%20:=%0A%20%20do%20t%20%E2%86%90%20infer_type%20h,%0A%20%20%20%20%20(unify%20e%20t%20%3E%3E%20return%20h)%20%3C%7C%3E%20find_same_type%20e%20hs%0A%0Ameta%20def%20assumption%20:%20tactic%20unit%20:=%0Ado%20ctx%20%E2%86%90%20local_context,%0A%20%20%20t%20%20%20%E2%86%90%20target,%0A%20%20%20h%20%20%20%E2%86%90%20find_same_type%20t%20ctx,%0A%20%20%20exact%20h%0A%3C%7C%3E%20fail%20%22assumption%20tactic%20failed%22%0A--%20END%0Aend%20hidden" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kd">meta</span> <span class="kd">def</span> <span class="n">find_same_type</span> <span class="o">:</span> <span class="n">expr</span> <span class="bp">&#8594;</span> <span class="n">list</span> <span class="n">expr</span> <span class="bp">&#8594;</span> <span class="n">tactic</span> <span class="n">expr</span>
<span class="bp">|</span> <span class="n">e</span> <span class="o">[]</span>         <span class="o">:=</span> <span class="n">failed</span>
<span class="bp">|</span> <span class="n">e</span> <span class="o">(</span><span class="n">h</span> <span class="o">::</span> <span class="n">hs</span><span class="o">)</span> <span class="o">:=</span>
  <span class="k">do</span> <span class="n">t</span> <span class="bp">&#8592;</span> <span class="n">infer_type</span> <span class="n">h</span><span class="o">,</span>
     <span class="o">(</span><span class="n">unify</span> <span class="n">e</span> <span class="n">t</span> <span class="bp">&gt;&gt;</span> <span class="n">return</span> <span class="n">h</span><span class="o">)</span> <span class="bp">&lt;|&gt;</span> <span class="n">find_same_type</span> <span class="n">e</span> <span class="n">hs</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">assumption</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span>
<span class="k">do</span> <span class="n">ctx</span> <span class="bp">&#8592;</span> <span class="n">local_context</span><span class="o">,</span>
   <span class="n">t</span>   <span class="bp">&#8592;</span> <span class="n">target</span><span class="o">,</span>
   <span class="n">h</span>   <span class="bp">&#8592;</span> <span class="n">find_same_type</span> <span class="n">t</span> <span class="n">ctx</span><span class="o">,</span>
   <span class="n">exact</span> <span class="n">h</span>
<span class="bp">&lt;|&gt;</span> <span class="n">fail</span> <span class="s2">&quot;assumption tactic failed&quot;</span>
</pre></div>
</div>
</div><p>The expression <code class="docutils literal notranslate"><span class="pre">find_same_type</span> <span class="pre">t</span> <span class="pre">es</span></code> tries to find in <code class="docutils literal notranslate"><span class="pre">es</span></code> an expression with type definitionally equal to <code class="docutils literal notranslate"><span class="pre">t</span></code> in the list of expressions <code class="docutils literal notranslate"><span class="pre">es</span></code>, by a straightforward recursion on the list. The <code class="docutils literal notranslate"><span class="pre">infer_type</span></code> tactic calls Lean&#8217;s internal type inference mechanism to infer to the type of an expression, and the <code class="docutils literal notranslate"><span class="pre">unify</span></code> tactic tries to unify two expressions, instantiating metavariables if necessary. Note the use of the <code class="docutils literal notranslate"><span class="pre">orelse</span></code> notation: if the unification fails, the procedure backtracks and continues to try the remaining elements on the list. The <code class="docutils literal notranslate"><span class="pre">fail</span></code> tactic announces failure with a given string. The <code class="docutils literal notranslate"><span class="pre">failed</span></code> tactic simply fails with a generic message, &#8220;tactic failed.&#8221;</p>
<p>One can even manipulate data structures that include tactics themselves. For example, the <code class="docutils literal notranslate"><span class="pre">first</span></code> tactic takes a list of tactics, and applies the first one that succeeds:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=open%20tactic%0A%0A--%20BEGIN%0Ameta%20def%20first%20%7B%CE%B1%20:%20Type%7D%20:%20list%20(tactic%20%CE%B1)%20%E2%86%92%20tactic%20%CE%B1%0A%7C%20%5B%5D%20%20%20%20%20%20:=%20fail%20%22first%20tactic%20failed,%20no%20more%20alternatives%22%0A%7C%20(t::ts)%20:=%20t%20%3C%7C%3E%20first%20ts%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kd">meta</span> <span class="kd">def</span> <span class="n">first</span> <span class="o">{</span><span class="n">&#945;</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">tactic</span> <span class="n">&#945;</span><span class="o">)</span> <span class="bp">&#8594;</span> <span class="n">tactic</span> <span class="n">&#945;</span>
<span class="bp">|</span> <span class="o">[]</span>      <span class="o">:=</span> <span class="n">fail</span> <span class="s2">&quot;first tactic failed, no more alternatives&quot;</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">t</span><span class="o">::</span><span class="n">ts</span><span class="o">)</span> <span class="o">:=</span> <span class="n">t</span> <span class="bp">&lt;|&gt;</span> <span class="n">first</span> <span class="n">ts</span>
</pre></div>
</div>
</div><p>It fails if none of the tactics on the list succeeds. Consider the following example:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=open%20tactic%20monad%20expr%0A%0A--%20BEGIN%0Ameta%20def%20destruct_conjunctions%20:%20tactic%20unit%20:=%0Arepeat%20(do%0A%20%20l%20%E2%86%90%20local_context,%0A%20%20first%20$%20l.map%20(%CE%BB%20h,%20do%0A%20%20%20%20ht%20%E2%86%90%20infer_type%20h%20%3E%3E=%20whnf,%0A%20%20%20%20match%20ht%20with%0A%20%20%20%20%7C%20%60(and%20%25%25a%20%25%25b)%20:=%20do%0A%20%20%20%20%20%20n%20%E2%86%90%20get_unused_name%20%60h%20none,%0A%20%20%20%20%20%20mk_mapp%20%60%60and.left%20%5Bnone,%20none,%20some%20h%5D%20%3E%3E=%20assertv%20n%20a,%0A%20%20%20%20%20%20n%20%E2%86%90%20get_unused_name%20%60h%20none,%0A%20%20%20%20%20%20mk_mapp%20%60%60and.right%20%5Bnone,%20none,%20some%20h%5D%20%3E%3E=%20assertv%20n%20b,%0A%20%20%20%20%20%20clear%20h%0A%20%20%20%20%7C%20_%20:=%20failed%0A%20%20%20%20end))%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kd">meta</span> <span class="kd">def</span> <span class="n">destruct_conjunctions</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span>
<span class="n">repeat</span> <span class="o">(</span><span class="k">do</span>
  <span class="n">l</span> <span class="bp">&#8592;</span> <span class="n">local_context</span><span class="o">,</span>
  <span class="n">first</span> <span class="bp">$</span> <span class="n">l.map</span> <span class="o">(</span><span class="bp">&#955;</span> <span class="n">h</span><span class="o">,</span> <span class="k">do</span>
    <span class="n">ht</span> <span class="bp">&#8592;</span> <span class="n">infer_type</span> <span class="n">h</span> <span class="bp">&gt;&gt;=</span> <span class="n">whnf</span><span class="o">,</span>
    <span class="k">match</span> <span class="n">ht</span> <span class="k">with</span>
    <span class="bp">|</span> <span class="bp">`</span><span class="o">(</span><span class="n">and</span> <span class="bp">%%</span><span class="n">a</span> <span class="bp">%%</span><span class="n">b</span><span class="o">)</span> <span class="o">:=</span> <span class="k">do</span>
      <span class="n">n</span> <span class="bp">&#8592;</span> <span class="n">get_unused_name</span> <span class="bp">`</span><span class="n">h</span> <span class="n">none</span><span class="o">,</span>
      <span class="n">mk_mapp</span> <span class="bp">``</span><span class="n">and.left</span> <span class="o">[</span><span class="n">none</span><span class="o">,</span> <span class="n">none</span><span class="o">,</span> <span class="n">some</span> <span class="n">h</span><span class="o">]</span> <span class="bp">&gt;&gt;=</span> <span class="n">assertv</span> <span class="n">n</span> <span class="n">a</span><span class="o">,</span>
      <span class="n">n</span> <span class="bp">&#8592;</span> <span class="n">get_unused_name</span> <span class="bp">`</span><span class="n">h</span> <span class="n">none</span><span class="o">,</span>
      <span class="n">mk_mapp</span> <span class="bp">``</span><span class="n">and.right</span> <span class="o">[</span><span class="n">none</span><span class="o">,</span> <span class="n">none</span><span class="o">,</span> <span class="n">some</span> <span class="n">h</span><span class="o">]</span> <span class="bp">&gt;&gt;=</span> <span class="n">assertv</span> <span class="n">n</span> <span class="n">b</span><span class="o">,</span>
      <span class="n">clear</span> <span class="n">h</span>
    <span class="bp">|</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">failed</span>
    <span class="kd">end</span><span class="o">))</span>
</pre></div>
</div>
</div><p>The <code class="docutils literal notranslate"><span class="pre">repeat</span></code> tactic simply repeats the inner block until it fails. The inner block starts by getting the local context. The expression <code class="docutils literal notranslate"><span class="pre">l.map</span> <span class="pre">...</span></code> is just shorthand for <code class="docutils literal notranslate"><span class="pre">list.map</span> <span class="pre">...</span> <span class="pre">l</span></code>; it applies the function in <code class="docutils literal notranslate"><span class="pre">...</span></code> to each element of <code class="docutils literal notranslate"><span class="pre">l</span></code> and returns the resulting list, in this case a list of tactics. The <code class="docutils literal notranslate"><span class="pre">first</span></code> function then calls each one sequentially until one of them succeeds. Note the use of the dollar-sign for function application. In general, an expression <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">$</span> <span class="pre">a</span></code> denotes nothing more than <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">a</span></code>, but the binding strength is such that you do not need to use extra parentheses when <code class="docutils literal notranslate"><span class="pre">a</span></code> is a long expression. This provides a convenient idiom in situations exactly like the one in the example.</p>
<p>Some of the elements of the body of the main loop will now be familiar. For each element <code class="docutils literal notranslate"><span class="pre">h</span></code> of the context, we infer the type of <code class="docutils literal notranslate"><span class="pre">h</span></code>, and reduce it to weak head normal form. (We will discuss weak head normal form in the next section.) Assuming the type is an <code class="docutils literal notranslate"><span class="pre">and</span></code>, we construct the terms <code class="docutils literal notranslate"><span class="pre">and.left</span> <span class="pre">h</span></code> and <code class="docutils literal notranslate"><span class="pre">and.right</span> <span class="pre">h</span></code> and add them to the context with a fresh name. The <code class="docutils literal notranslate"><span class="pre">clear</span></code> tactic then deletes <code class="docutils literal notranslate"><span class="pre">h</span></code> itself.</p>
<p>Remember that when writing <code class="docutils literal notranslate"><span class="pre">meta</span> <span class="pre">defs</span></code> you can carry out arbitrary recursive calls, without any guarantee of termination. You should use this with caution when writing tactics; if there is any chance that some unforseen circumstance will result in an infinite loop, it is wiser to use a large cutoff to prevent the tactic from hanging. Even the <code class="docutils literal notranslate"><span class="pre">repeat</span></code> tactic is implemented as a finite iteration:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=open%20tactic%20nat%0Anamespace%20hidden%0A%0A--%20BEGIN%0Ameta%20def%20repeat_at_most%20:%20nat%20%E2%86%92%20tactic%20unit%20%E2%86%92%20tactic%20unit%0A%7C%200%20%20%20%20%20%20%20%20t%20:=%20skip%0A%7C%20(succ%20n)%20t%20:=%20(do%20t,%20repeat_at_most%20n%20t)%20%3C%7C%3E%20skip%0A%0Ameta%20def%20repeat%20:%20tactic%20unit%20%E2%86%92%20tactic%20unit%20:=%0Arepeat_at_most%20100000%0A--%20END%0A%0Aend%20hidden" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kd">meta</span> <span class="kd">def</span> <span class="n">repeat_at_most</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">&#8594;</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="bp">&#8594;</span> <span class="n">tactic</span> <span class="n">unit</span>
<span class="bp">|</span> <span class="mi">0</span>        <span class="n">t</span> <span class="o">:=</span> <span class="n">skip</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">succ</span> <span class="n">n</span><span class="o">)</span> <span class="n">t</span> <span class="o">:=</span> <span class="o">(</span><span class="k">do</span> <span class="n">t</span><span class="o">,</span> <span class="n">repeat_at_most</span> <span class="n">n</span> <span class="n">t</span><span class="o">)</span> <span class="bp">&lt;|&gt;</span> <span class="n">skip</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">repeat</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="bp">&#8594;</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span>
<span class="n">repeat_at_most</span> <span class="mi">100000</span>
</pre></div>
</div>
</div><p>But 100,000 iterations is still enough to get you into trouble if you are not careful.</p>
</div>
<div class="section" id="reduction">
<h2>5.4. Reduction<a class="headerlink" href="#reduction" title="Permalink to this headline">&#182;</a></h2>
<p>[This section still under construction. It will discuss the various types of reduction, the notion of weak head normal form, and the various transparency settings. It will use some of the examples that follow.]</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=open%20tactic%0A%0Aset_option%20pp.beta%20false%0A%0Asection%0A%20%20variables%20%7B%CE%B1%20:%20Type%7D%20(a%20b%20:%20%CE%B1)%0A%0A%20%20example%20:%20(%CE%BB%20x%20:%20%CE%B1,%20a)%20b%20=%20a%20:=%0A%20%20by%20do%20goal%20%E2%86%90%20target,%0A%20%20%20%20%20%20%20%20match%20expr.is_eq%20goal%20with%0A%20%20%20%20%20%20%20%20%7C%20(some%20(e%E2%82%81,%20e%E2%82%82))%20:=%20do%20trace%20e%E2%82%81,%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20whnf%20e%E2%82%81%20%3E%3E=%20trace,%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20reflexivity%0A%20%20%20%20%20%20%20%20%7C%20none%20%20%20%20%20%20%20%20%20%20%20%20:=%20failed%0A%20%20%20%20%20%20%20%20end%0A%0A%20%20example%20:%20(%CE%BB%20x%20:%20%CE%B1,%20a)%20b%20=%20a%20:=%0A%20%20by%20do%20goal%20%E2%86%90%20target,%0A%20%20%20%20%20%20%20%20match%20expr.is_eq%20goal%20with%0A%20%20%20%20%20%20%20%20%7C%20(some%20(e%E2%82%81,%20e%E2%82%82))%20:=%20do%20trace%20e%E2%82%81,%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20whnf%20e%E2%82%81%20transparency.none%20%3E%3E=%20trace,%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20reflexivity%0A%20%20%20%20%20%20%20%20%7C%20none%20%20%20%20%20%20%20%20%20%20%20%20:=%20failed%0A%20%20%20%20%20%20%20%20end%0A%0A%20%20attribute%20%5Breducible%5D%0A%20%20definition%20foo%20(a%20b%20:%20%CE%B1)%20:%20%CE%B1%20:=%20a%0A%0A%20%20example%20:%20foo%20a%20b%20=%20a%20:=%0A%20%20by%20do%20goal%20%E2%86%90%20target,%0A%20%20%20%20%20%20%20%20match%20expr.is_eq%20goal%20with%0A%20%20%20%20%20%20%20%20%7C%20(some%20(e%E2%82%81,%20e%E2%82%82))%20:=%20do%20trace%20e%E2%82%81,%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20whnf%20e%E2%82%81%20transparency.none%20%3E%3E=%20trace,%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20reflexivity%0A%20%20%20%20%20%20%20%20%7C%20none%20%20%20%20%20%20%20%20%20%20%20%20:=%20failed%0A%20%20%20%20%20%20%20%20end%0A%0A%20%20example%20:%20foo%20a%20b%20=%20a%20:=%0A%20%20by%20do%20goal%20%E2%86%90%20target,%0A%20%20%20%20%20%20%20%20match%20expr.is_eq%20goal%20with%0A%20%20%20%20%20%20%20%20%7C%20(some%20(e%E2%82%81,%20e%E2%82%82))%20:=%20do%20trace%20e%E2%82%81,%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20whnf%20e%E2%82%81%20transparency.reducible%20%3E%3E=%20trace,%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20reflexivity%0A%20%20%20%20%20%20%20%20%7C%20none%20%20%20%20%20%20%20%20%20%20%20%20:=%20failed%0A%20%20%20%20%20%20%20%20end%0Aend" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kn">open</span> <span class="n">tactic</span>

<span class="kd">set_option</span> <span class="n">pp.beta</span> <span class="n">false</span>

<span class="kn">section</span>
  <span class="kd">variables</span> <span class="o">{</span><span class="n">&#945;</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">&#945;</span><span class="o">)</span>

  <span class="kd">example</span> <span class="o">:</span> <span class="o">(</span><span class="bp">&#955;</span> <span class="n">x</span> <span class="o">:</span> <span class="n">&#945;</span><span class="o">,</span> <span class="n">a</span><span class="o">)</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">a</span> <span class="o">:=</span>
  <span class="kd">by</span> <span class="k">do</span> <span class="n">goal</span> <span class="bp">&#8592;</span> <span class="n">target</span><span class="o">,</span>
        <span class="k">match</span> <span class="n">expr.is_eq</span> <span class="n">goal</span> <span class="k">with</span>
        <span class="bp">|</span> <span class="o">(</span><span class="n">some</span> <span class="o">(</span><span class="n">e&#8321;</span><span class="o">,</span> <span class="n">e&#8322;</span><span class="o">))</span> <span class="o">:=</span> <span class="k">do</span> <span class="n">trace</span> <span class="n">e&#8321;</span><span class="o">,</span>
                                <span class="n">whnf</span> <span class="n">e&#8321;</span> <span class="bp">&gt;&gt;=</span> <span class="n">trace</span><span class="o">,</span>
                                <span class="n">reflexivity</span>
        <span class="bp">|</span> <span class="n">none</span>            <span class="o">:=</span> <span class="n">failed</span>
        <span class="kd">end</span>

  <span class="kd">example</span> <span class="o">:</span> <span class="o">(</span><span class="bp">&#955;</span> <span class="n">x</span> <span class="o">:</span> <span class="n">&#945;</span><span class="o">,</span> <span class="n">a</span><span class="o">)</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">a</span> <span class="o">:=</span>
  <span class="kd">by</span> <span class="k">do</span> <span class="n">goal</span> <span class="bp">&#8592;</span> <span class="n">target</span><span class="o">,</span>
        <span class="k">match</span> <span class="n">expr.is_eq</span> <span class="n">goal</span> <span class="k">with</span>
        <span class="bp">|</span> <span class="o">(</span><span class="n">some</span> <span class="o">(</span><span class="n">e&#8321;</span><span class="o">,</span> <span class="n">e&#8322;</span><span class="o">))</span> <span class="o">:=</span> <span class="k">do</span> <span class="n">trace</span> <span class="n">e&#8321;</span><span class="o">,</span>
                                <span class="n">whnf</span> <span class="n">e&#8321;</span> <span class="n">transparency.none</span> <span class="bp">&gt;&gt;=</span> <span class="n">trace</span><span class="o">,</span>
                                <span class="n">reflexivity</span>
        <span class="bp">|</span> <span class="n">none</span>            <span class="o">:=</span> <span class="n">failed</span>
        <span class="kd">end</span>

  <span class="kn">attribute</span> <span class="o">[</span><span class="n">reducible</span><span class="o">]</span>
  <span class="kd">definition</span> <span class="n">foo</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">&#945;</span><span class="o">)</span> <span class="o">:</span> <span class="n">&#945;</span> <span class="o">:=</span> <span class="n">a</span>

  <span class="kd">example</span> <span class="o">:</span> <span class="n">foo</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">a</span> <span class="o">:=</span>
  <span class="kd">by</span> <span class="k">do</span> <span class="n">goal</span> <span class="bp">&#8592;</span> <span class="n">target</span><span class="o">,</span>
        <span class="k">match</span> <span class="n">expr.is_eq</span> <span class="n">goal</span> <span class="k">with</span>
        <span class="bp">|</span> <span class="o">(</span><span class="n">some</span> <span class="o">(</span><span class="n">e&#8321;</span><span class="o">,</span> <span class="n">e&#8322;</span><span class="o">))</span> <span class="o">:=</span> <span class="k">do</span> <span class="n">trace</span> <span class="n">e&#8321;</span><span class="o">,</span>
                                <span class="n">whnf</span> <span class="n">e&#8321;</span> <span class="n">transparency.none</span> <span class="bp">&gt;&gt;=</span> <span class="n">trace</span><span class="o">,</span>
                                <span class="n">reflexivity</span>
        <span class="bp">|</span> <span class="n">none</span>            <span class="o">:=</span> <span class="n">failed</span>
        <span class="kd">end</span>

  <span class="kd">example</span> <span class="o">:</span> <span class="n">foo</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">a</span> <span class="o">:=</span>
  <span class="kd">by</span> <span class="k">do</span> <span class="n">goal</span> <span class="bp">&#8592;</span> <span class="n">target</span><span class="o">,</span>
        <span class="k">match</span> <span class="n">expr.is_eq</span> <span class="n">goal</span> <span class="k">with</span>
        <span class="bp">|</span> <span class="o">(</span><span class="n">some</span> <span class="o">(</span><span class="n">e&#8321;</span><span class="o">,</span> <span class="n">e&#8322;</span><span class="o">))</span> <span class="o">:=</span> <span class="k">do</span> <span class="n">trace</span> <span class="n">e&#8321;</span><span class="o">,</span>
                                <span class="n">whnf</span> <span class="n">e&#8321;</span> <span class="n">transparency.reducible</span> <span class="bp">&gt;&gt;=</span> <span class="n">trace</span><span class="o">,</span>
                                <span class="n">reflexivity</span>
        <span class="bp">|</span> <span class="n">none</span>            <span class="o">:=</span> <span class="n">failed</span>
        <span class="kd">end</span>
<span class="kd">end</span>
</pre></div>
</div>
</div></div>
<div class="section" id="metavariables-and-unification">
<span id="id2"></span><h2>5.5. Metavariables and Unification<a class="headerlink" href="#metavariables-and-unification" title="Permalink to this headline">&#182;</a></h2>
<p>[This section is still under construction. It will discuss the notion of a metavariable and its local context, with the interesting bit of information that goals in the tactic state are nothing more than metavariables. So the goal list is really just a list of metavariables, which can help us make sense of the <code class="docutils literal notranslate"><span class="pre">get_goals</span></code> and <code class="docutils literal notranslate"><span class="pre">set_goals</span></code> tactics. It will also discuss the <code class="docutils literal notranslate"><span class="pre">unify</span></code> tactic.]</p>
</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">Programming in Lean</a></h1>








<!-- <h3>Navigation</h3> -->
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="introduction.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="types_and_terms.html">2. Types and Terms</a></li>
<li class="toctree-l1"><a class="reference internal" href="basic_programming.html">3. Basic Programming</a></li>
<li class="toctree-l1"><a class="reference internal" href="monads.html">4. Monads</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">5. Writing Tactics</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#a-first-look-at-the-tactic-monad">5.1. A First Look at the Tactic Monad</a></li>
<li class="toctree-l2"><a class="reference internal" href="#names-and-expressions">5.2. Names and Expressions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#examples">5.3. Examples</a></li>
<li class="toctree-l2"><a class="reference internal" href="#reduction">5.4. Reduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="#metavariables-and-unification">5.5. Metavariables and Unification</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="writing_automation.html">6. Writing Automation</a></li>
</ul>


<hr />
<ul>
    
    <li class="toctree-l1"><a href="programming_in_lean.pdf">PDF version</a></li>
    
    <li class="toctree-l1"><a href="https://leanprover.github.io/">Lean Home</a></li>
    
</ul>

<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2017, Jeremy Avigad and Simon Hudon.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.8.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/writing_tactics.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>