
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=ascii" />
    <title>4. Monads &#8212; Programming in Lean 3.4.2 documentation</title>
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/language_data.js"></script>
    <link rel="shortcut icon" href="_static/favicon.ico"/>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="5. Writing Tactics" href="writing_tactics.html" />
    <link rel="prev" title="3. Basic Programming" href="basic_programming.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="monads">
<span id="id1"></span><h1>4. Monads<a class="headerlink" href="#monads" title="Permalink to this headline">&#182;</a></h1>
<p>In this chapter, we will describe a powerful abstraction known as a <em>monad</em>. A monad is a type constructor <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">:</span> <span class="pre">Type</span> <span class="pre">&#8594;</span> <span class="pre">Type</span></code> that comes equipped with two special operations, <code class="docutils literal notranslate"><span class="pre">return</span></code> and <code class="docutils literal notranslate"><span class="pre">bind</span></code>. If <code class="docutils literal notranslate"><span class="pre">&#945;</span></code> is any type, think of <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">&#945;</span></code> as being a &#8220;virtual <code class="docutils literal notranslate"><span class="pre">&#945;</span></code>,&#8221; or, as some people describe it, &#8220;an <code class="docutils literal notranslate"><span class="pre">&#945;</span></code> inside a box.&#8221;</p>
<p>For a given monad <code class="docutils literal notranslate"><span class="pre">m</span></code>, the function <code class="docutils literal notranslate"><span class="pre">return</span></code> has type <code class="docutils literal notranslate"><span class="pre">&#928;</span> <span class="pre">{&#945;</span> <span class="pre">:</span> <span class="pre">Type},</span> <span class="pre">&#945;</span> <span class="pre">&#8594;</span> <span class="pre">m</span> <span class="pre">&#945;</span></code>. The idea is that for any element <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">:</span> <span class="pre">&#945;</span></code>, <code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">a</span></code> produces the virtual version of <code class="docutils literal notranslate"><span class="pre">a</span></code>, or puts <code class="docutils literal notranslate"><span class="pre">a</span></code> inside the box.</p>
<p>Once we are inside the box, we cannot get out; there is no general way of taking an element of <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">&#945;</span></code> and obtaining an element of <code class="docutils literal notranslate"><span class="pre">&#945;</span></code>. But the <code class="docutils literal notranslate"><span class="pre">bind</span></code> operation gives us a way of turning some operations on <code class="docutils literal notranslate"><span class="pre">&#945;</span></code> into operations inside the monad. Specifically, for a given monad <code class="docutils literal notranslate"><span class="pre">m</span></code>, the function <code class="docutils literal notranslate"><span class="pre">bind</span></code> has type <code class="docutils literal notranslate"><span class="pre">&#928;</span> <span class="pre">{&#945;</span> <span class="pre">&#946;</span> <span class="pre">:</span> <span class="pre">Type},</span> <span class="pre">m</span> <span class="pre">&#945;</span> <span class="pre">&#8594;</span> <span class="pre">(&#945;</span> <span class="pre">&#8594;</span> <span class="pre">m</span> <span class="pre">&#946;)</span> <span class="pre">&#8594;</span> <span class="pre">m</span> <span class="pre">&#946;</span></code>. Suppose we have a function <code class="docutils literal notranslate"><span class="pre">f</span></code> that, given any element <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">:</span> <span class="pre">&#945;</span></code>, produces a virtual element of <code class="docutils literal notranslate"><span class="pre">&#946;</span></code>; in more prosaic terms, <code class="docutils literal notranslate"><span class="pre">f</span></code> has type <code class="docutils literal notranslate"><span class="pre">&#945;</span> <span class="pre">&#8594;</span> <span class="pre">m</span> <span class="pre">&#946;</span></code>. Suppose also that we have a virtual element of <code class="docutils literal notranslate"><span class="pre">&#945;</span></code>, that is, <code class="docutils literal notranslate"><span class="pre">ma</span> <span class="pre">:</span> <span class="pre">m</span> <span class="pre">&#945;</span></code>. If we could extract from <code class="docutils literal notranslate"><span class="pre">ma</span></code> a corresponding element <code class="docutils literal notranslate"><span class="pre">a</span></code> of <code class="docutils literal notranslate"><span class="pre">&#945;</span></code>, we could apply <code class="docutils literal notranslate"><span class="pre">f</span></code> to it to get a virtual element of <code class="docutils literal notranslate"><span class="pre">&#946;</span></code>. We cannot do that in general, but <code class="docutils literal notranslate"><span class="pre">bind</span></code> gives us a way of simulating the compound operation: it applies <code class="docutils literal notranslate"><span class="pre">f</span></code> directly &#8220;inside the box,&#8221; and gives us an element of <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">&#946;</span></code>.</p>
<p>As an example of how <code class="docutils literal notranslate"><span class="pre">bind</span></code> and <code class="docutils literal notranslate"><span class="pre">return</span></code> can be used, given any function <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">:</span> <span class="pre">&#945;</span> <span class="pre">&#8594;</span> <span class="pre">&#946;</span></code>, we can get a function <code class="docutils literal notranslate"><span class="pre">map</span> <span class="pre">f</span> <span class="pre">:</span> <span class="pre">m</span> <span class="pre">&#945;</span> <span class="pre">&#8594;</span> <span class="pre">m</span> <span class="pre">&#946;</span></code> by defining <code class="docutils literal notranslate"><span class="pre">map</span> <span class="pre">f</span> <span class="pre">ma</span></code> to be <code class="docutils literal notranslate"><span class="pre">bind</span> <span class="pre">ma</span> <span class="pre">(&#955;</span> <span class="pre">a,</span> <span class="pre">return</span> <span class="pre">(f</span> <span class="pre">a)</span></code>. Roughly, given <code class="docutils literal notranslate"><span class="pre">ma</span> <span class="pre">:</span> <span class="pre">m</span> <span class="pre">&#945;</span></code>, the <code class="docutils literal notranslate"><span class="pre">bind</span></code> reaches into the box, finds an associated <code class="docutils literal notranslate"><span class="pre">a</span></code>, and then puts <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">a</span></code> back into the box.</p>
<p>For another example, given any element <code class="docutils literal notranslate"><span class="pre">mma</span> <span class="pre">:</span> <span class="pre">m</span> <span class="pre">(m</span> <span class="pre">&#945;)</span></code>, the expression <code class="docutils literal notranslate"><span class="pre">monad.bind</span> <span class="pre">mma</span> <span class="pre">id</span></code> has type <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">&#945;</span></code>. This means that even though we cannot in general extract an element of <code class="docutils literal notranslate"><span class="pre">&#946;</span></code> from <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">&#946;</span></code>, we <em>can</em> do it when <code class="docutils literal notranslate"><span class="pre">&#946;</span></code> itself is a virtual type, <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">&#945;</span></code>. The expression <code class="docutils literal notranslate"><span class="pre">monad.bind</span> <span class="pre">mma</span> <span class="pre">id</span></code> reaches into the <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">(m</span> <span class="pre">&#945;)</span></code> box, catches hold of an element of <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">&#945;</span></code>, and simply leaves it in the <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">&#945;</span></code> box.</p>
<p>If you have never come across the notion of a monad before, these operations will seem quite mysterious. But instances of <code class="docutils literal notranslate"><span class="pre">return</span></code> and <code class="docutils literal notranslate"><span class="pre">bind</span></code> arise in many natural ways, and the goal of this chapter is to show you some examples. Roughly, they arise in situations where <code class="docutils literal notranslate"><span class="pre">m</span></code> is a type construction with the property that functions in the ordinary realm of types can be transported, uniformly, into functions in the realm of <code class="docutils literal notranslate"><span class="pre">m</span></code>-types. This should sound quite general, and so it is perhaps not that surprising that monads be instantiated in many different ways. The power of the abstraction is not only that it provides general functions and notation the can be used in all these various instantiations, but also that it provides a helpful way of thinking about what they all have in common.</p>
<p>Lean implements the following common notation. First, we have the infix notation</p>
<div class="highlight-text notranslate"><div class="highlight"><pre>ma &gt;&gt;= f
</pre></div>
</div>
<p>for <code class="docutils literal notranslate"><span class="pre">bind</span> <span class="pre">ma</span> <span class="pre">f</span></code>. Think of this as saying &#8220;take an element <code class="docutils literal notranslate"><span class="pre">a</span></code> out of the box, and send it to <code class="docutils literal notranslate"><span class="pre">f</span></code>.&#8221; Remember, we are allowed to do that as long as the return type of <code class="docutils literal notranslate"><span class="pre">f</span></code> is of the form <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">&#946;</span></code>. We also have the infix notation,</p>
<div class="highlight-text notranslate"><div class="highlight"><pre>ma &gt;&gt; mb
</pre></div>
</div>
<p>for <code class="docutils literal notranslate"><span class="pre">bind</span> <span class="pre">ma</span> <span class="pre">(&#955;</span> <span class="pre">a,</span> <span class="pre">mb)</span></code>. This takes an element <code class="docutils literal notranslate"><span class="pre">a</span></code> out of the box, ignores it entirely, and then returns <code class="docutils literal notranslate"><span class="pre">mb</span></code>. These two pieces of notation are most useful in situations where the act of taking an element of the box can be viewed as inducing a change of state. In situations like that, you can think of <code class="docutils literal notranslate"><span class="pre">ma</span> <span class="pre">&gt;&gt;=</span> <span class="pre">f</span></code> as saying &#8220;do <code class="docutils literal notranslate"><span class="pre">ma</span></code>, take the result, and then send it to <code class="docutils literal notranslate"><span class="pre">f</span></code>.&#8221; You can then think of of <code class="docutils literal notranslate"><span class="pre">ma</span> <span class="pre">&gt;&gt;</span> <span class="pre">mb</span></code> more simply as &#8220;do <code class="docutils literal notranslate"><span class="pre">ma</span></code>, then do <code class="docutils literal notranslate"><span class="pre">mb</span></code>.&#8221; In this way, monads provide a way of simulating features of imperative programming languages in a functional setting. But, we will see, they do a lot more than that.</p>
<p>Thinking of monads in terms of performing actions while computing results is quite powerful, and Lean provides notation to support that perspective. The expression</p>
<div class="highlight-text notranslate"><div class="highlight"><pre>do a &#8592; ma, t
</pre></div>
</div>
<p>is syntactic sugar for <code class="docutils literal notranslate"><span class="pre">ma</span> <span class="pre">&gt;&gt;=</span> <span class="pre">(&#955;</span> <span class="pre">a,</span> <span class="pre">t)</span></code>. Here <code class="docutils literal notranslate"><span class="pre">t</span></code> is typically an expression that depends on <code class="docutils literal notranslate"><span class="pre">a</span></code>, and it should have type <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">&#946;</span></code> for some <code class="docutils literal notranslate"><span class="pre">&#946;</span></code>. So you can read <code class="docutils literal notranslate"><span class="pre">do</span> <span class="pre">a</span> <span class="pre">&#8592;</span> <span class="pre">ma,</span> <span class="pre">t</span></code> as reaching into the box, extracting an <code class="docutils literal notranslate"><span class="pre">a</span></code>, and then continuing the computation with <code class="docutils literal notranslate"><span class="pre">t</span></code>. Similarly, <code class="docutils literal notranslate"><span class="pre">do</span> <span class="pre">s,</span> <span class="pre">t</span></code> is syntactic sugar for <code class="docutils literal notranslate"><span class="pre">s</span> <span class="pre">&gt;&gt;</span> <span class="pre">t</span></code>, supporting the reading &#8220;do <code class="docutils literal notranslate"><span class="pre">s</span></code>, then do <code class="docutils literal notranslate"><span class="pre">t</span></code>.&#8221; The notation supports iteration, so, for example,</p>
<div class="highlight-text notranslate"><div class="highlight"><pre>do a &#8592; s,
   b &#8592; t,
   f a b,
   return (g a b)
</pre></div>
</div>
<p>is syntactic sugar for</p>
<div class="highlight-text notranslate"><div class="highlight"><pre>bind s (&#955; a, bind t (&#955; b, bind (f a b) (&#955; c, return (g a b)))).
</pre></div>
</div>
<p>It supports the reading &#8220;do <code class="docutils literal notranslate"><span class="pre">s</span></code> and extract <code class="docutils literal notranslate"><span class="pre">a</span></code>, do <code class="docutils literal notranslate"><span class="pre">t</span></code> and extract <code class="docutils literal notranslate"><span class="pre">b</span></code>, do <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">a</span> <span class="pre">b</span></code>, then return the value <code class="docutils literal notranslate"><span class="pre">g</span> <span class="pre">a</span> <span class="pre">b</span></code>.&#8221;</p>
<p>Incidentally, as you may have guessed, a monad is implemented as a type class in Lean. In other words, <code class="docutils literal notranslate"><span class="pre">return</span></code> really has type</p>
<div class="highlight-text notranslate"><div class="highlight"><pre>&#928; {m : Type &#8594; Type} [monad m] {&#945; : Type}, &#945; &#8594; m &#945;},
</pre></div>
</div>
<p>and <code class="docutils literal notranslate"><span class="pre">bind</span></code> really has type</p>
<div class="highlight-text notranslate"><div class="highlight"><pre>&#928; {m : Type &#8594; Type} [monad m] {&#945; &#946; : Type}, m &#945; &#8594; (&#945; &#8594; m &#946;) &#8594; m &#946;.
</pre></div>
</div>
<p>In general, the relevant monad can be inferred from the expressions in which <code class="docutils literal notranslate"><span class="pre">bind</span></code> and <code class="docutils literal notranslate"><span class="pre">return</span></code> appear, and the monad structure is then inferred by type class inference.</p>
<p>There is a constraint, namely that when we use monads all the types we apply the monad to have to live in the same type universe. When all the types in question appear as parameters to a definition, Lean&#8217;s elaborator will infer that constraint. When we declare variables below, we will satisfy that constraint by explicitly putting them in the same universe.</p>
<div class="section" id="the-option-monad">
<h2>4.1. The option monad<a class="headerlink" href="#the-option-monad" title="Permalink to this headline">&#182;</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">option</span></code> constructor provides what is perhaps the simplest example of a monad. Recall that an element of <code class="docutils literal notranslate"><span class="pre">option</span> <span class="pre">&#945;</span></code> is either of the form <code class="docutils literal notranslate"><span class="pre">some</span> <span class="pre">a</span></code> for some element <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">:</span> <span class="pre">&#945;</span></code>, or <code class="docutils literal notranslate"><span class="pre">none</span></code>. So an element <code class="docutils literal notranslate"><span class="pre">a</span></code> of <code class="docutils literal notranslate"><span class="pre">option</span> <span class="pre">&#945;</span></code> is a &#8220;virtual <code class="docutils literal notranslate"><span class="pre">&#945;</span></code>&#8221; in the sense of being either an element of <code class="docutils literal notranslate"><span class="pre">&#945;</span></code> or an empty promise.</p>
<p>The associated <code class="docutils literal notranslate"><span class="pre">return</span></code> is just <code class="docutils literal notranslate"><span class="pre">some</span></code>: given an element <code class="docutils literal notranslate"><span class="pre">a</span></code> of <code class="docutils literal notranslate"><span class="pre">&#945;</span></code>, <code class="docutils literal notranslate"><span class="pre">some</span> <span class="pre">a</span></code> returns a virtual <code class="docutils literal notranslate"><span class="pre">&#945;</span></code>. It is also clear that we cannot go in the opposite direction: given an element <code class="docutils literal notranslate"><span class="pre">ma</span> <span class="pre">:</span> <span class="pre">option</span> <span class="pre">&#945;</span></code>, there is no way, in general, of producing an element of <code class="docutils literal notranslate"><span class="pre">&#945;</span></code>. But we can simulate extraction of such an element as long as we are willing to stay in the virtual land of <code class="docutils literal notranslate"><span class="pre">options</span></code>, by defining <code class="docutils literal notranslate"><span class="pre">bind</span></code> as follows:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=namespace%20hidden%0A%0A--%20BEGIN%0Adef%20bind%20%7B%CE%B1%20%CE%B2%20:%20Type%7D%20(oa%20:%20option%20%CE%B1)%20(f%20:%20%CE%B1%20%E2%86%92%20option%20%CE%B2)%20:%0A%20%20option%20%CE%B2%20:=%0Amatch%20oa%20with%0A%7C%20(some%20a)%20:=%20f%20a%0A%7C%20none%20%20%20%20%20:=%20none%0Aend%0A--%20END%0A%0Aend%20hidden" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kd">def</span> <span class="n">bind</span> <span class="o">{</span><span class="n">&#945;</span> <span class="n">&#946;</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">oa</span> <span class="o">:</span> <span class="n">option</span> <span class="n">&#945;</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">&#945;</span> <span class="bp">&#8594;</span> <span class="n">option</span> <span class="n">&#946;</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">option</span> <span class="n">&#946;</span> <span class="o">:=</span>
<span class="k">match</span> <span class="n">oa</span> <span class="k">with</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">some</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span> <span class="n">f</span> <span class="n">a</span>
<span class="bp">|</span> <span class="n">none</span>     <span class="o">:=</span> <span class="n">none</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>If the element <code class="docutils literal notranslate"><span class="pre">oa</span></code> is <code class="docutils literal notranslate"><span class="pre">some</span> <span class="pre">a</span></code>, we can simply apply <code class="docutils literal notranslate"><span class="pre">f</span></code> to <code class="docutils literal notranslate"><span class="pre">a</span></code>, and otherwise we simply return <code class="docutils literal notranslate"><span class="pre">none</span></code>. Notice how the <code class="docutils literal notranslate"><span class="pre">do</span></code> notation allows us to chain these operations:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=universe%20u%0Avariables%20%7B%CE%B1%20%CE%B2%20%CE%B3%20%CE%B4%20:%20Type.%7Bu%7D%7D%20(oa%20:%20option%20%CE%B1)%0Avariables%20(f%20:%20%CE%B1%20%E2%86%92%20option%20%CE%B2)%20(g%20:%20%CE%B1%20%E2%86%92%20%CE%B2%20%E2%86%92%20option%20%CE%B3)%0A%20%20%20%20%20%20%20%20%20%20(h%20:%20%CE%B1%20%E2%86%92%20%CE%B2%20%E2%86%92%20%CE%B3%20%E2%86%92%20option%20%CE%B4)%0A%0Aexample%20:%20option%20%CE%B2%20:=%0Ado%20a%20%E2%86%90%20oa,%0A%20%20%20b%20%E2%86%90%20f%20a,%0A%20%20%20return%20b%0A%0Aexample%20:%20option%20%CE%B4%20:=%0Ado%20a%20%E2%86%90%20oa,%0A%20%20%20b%20%E2%86%90%20f%20a,%0A%20%20%20c%20%E2%86%90%20g%20a%20b,%0A%20%20%20h%20a%20b%20c" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kd">universe</span> <span class="n">u</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">&#945;</span> <span class="n">&#946;</span> <span class="n">&#947;</span> <span class="n">&#948;</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span><span class="o">}}</span> <span class="o">(</span><span class="n">oa</span> <span class="o">:</span> <span class="n">option</span> <span class="n">&#945;</span><span class="o">)</span>
<span class="kd">variables</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">&#945;</span> <span class="bp">&#8594;</span> <span class="n">option</span> <span class="n">&#946;</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">&#945;</span> <span class="bp">&#8594;</span> <span class="n">&#946;</span> <span class="bp">&#8594;</span> <span class="n">option</span> <span class="n">&#947;</span><span class="o">)</span>
          <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">&#945;</span> <span class="bp">&#8594;</span> <span class="n">&#946;</span> <span class="bp">&#8594;</span> <span class="n">&#947;</span> <span class="bp">&#8594;</span> <span class="n">option</span> <span class="n">&#948;</span><span class="o">)</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">option</span> <span class="n">&#946;</span> <span class="o">:=</span>
<span class="k">do</span> <span class="n">a</span> <span class="bp">&#8592;</span> <span class="n">oa</span><span class="o">,</span>
   <span class="n">b</span> <span class="bp">&#8592;</span> <span class="n">f</span> <span class="n">a</span><span class="o">,</span>
   <span class="n">return</span> <span class="n">b</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">option</span> <span class="n">&#948;</span> <span class="o">:=</span>
<span class="k">do</span> <span class="n">a</span> <span class="bp">&#8592;</span> <span class="n">oa</span><span class="o">,</span>
   <span class="n">b</span> <span class="bp">&#8592;</span> <span class="n">f</span> <span class="n">a</span><span class="o">,</span>
   <span class="n">c</span> <span class="bp">&#8592;</span> <span class="n">g</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span>
   <span class="n">h</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span>
</pre></div>
</div>
</div><p>Think of <code class="docutils literal notranslate"><span class="pre">f</span></code>, <code class="docutils literal notranslate"><span class="pre">g</span></code>, and <code class="docutils literal notranslate"><span class="pre">h</span></code> as being partial functions on their respective domains, where a return value of <code class="docutils literal notranslate"><span class="pre">none</span></code> indicates that the function is undefined for the given input. Intuitively, the second example above returns <code class="docutils literal notranslate"><span class="pre">h</span> <span class="pre">a</span> <span class="pre">(f</span> <span class="pre">a)</span> <span class="pre">(g</span> <span class="pre">a</span> <span class="pre">(f</span> <span class="pre">a))</span></code>, assuming <code class="docutils literal notranslate"><span class="pre">oa</span></code> is <code class="docutils literal notranslate"><span class="pre">some</span> <span class="pre">a</span></code> and all the subterms of that expression are defined. The expression <code class="docutils literal notranslate"><span class="pre">h</span> <span class="pre">a</span> <span class="pre">(f</span> <span class="pre">a)</span> <span class="pre">(g</span> <span class="pre">a</span> <span class="pre">(f</span> <span class="pre">a))</span></code> does not actually type check; for example, the second argument of <code class="docutils literal notranslate"><span class="pre">h</span></code> should be of type <code class="docutils literal notranslate"><span class="pre">&#946;</span></code> rather than <code class="docutils literal notranslate"><span class="pre">option</span> <span class="pre">&#946;</span></code>. But monadic notation allows us to simulate the computation of a possibly undefined term, where the bind operation serves to percolate a value of <code class="docutils literal notranslate"><span class="pre">none</span></code> to the output.</p>
</div>
<div class="section" id="the-list-monad">
<h2>4.2. The list monad<a class="headerlink" href="#the-list-monad" title="Permalink to this headline">&#182;</a></h2>
<p>Our next example of a monad is the <code class="docutils literal notranslate"><span class="pre">list</span></code> monad. In the last section we thought of a function <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">:</span> <span class="pre">&#945;</span> <span class="pre">&#8594;</span> <span class="pre">option</span> <span class="pre">&#946;</span></code> as a function which, on input <code class="docutils literal notranslate"><span class="pre">&#945;</span></code>, possibly returns an element of <code class="docutils literal notranslate"><span class="pre">&#946;</span></code>. Now we will think of a function <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">:</span> <span class="pre">&#945;</span> <span class="pre">&#8594;</span> <span class="pre">list</span> <span class="pre">&#946;</span></code> as a function which, on input <code class="docutils literal notranslate"><span class="pre">&#945;</span></code>, returns a list of possible values for the output. This monad is sometimes also called the <code class="docutils literal notranslate"><span class="pre">nondeterministic</span></code> monad, since we can think of <code class="docutils literal notranslate"><span class="pre">f</span></code> as a computation which may nondeterministically return any of the elements in the list.</p>
<p>It is easy to insert a value <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">:</span> <span class="pre">&#945;</span></code> into <code class="docutils literal notranslate"><span class="pre">list</span> <span class="pre">&#945;</span></code>; we define <code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">a</span></code> to be just the singleton list <code class="docutils literal notranslate"><span class="pre">[a]</span></code>. Now, given <code class="docutils literal notranslate"><span class="pre">la</span> <span class="pre">:</span> <span class="pre">list</span> <span class="pre">&#945;</span></code> and <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">:</span> <span class="pre">&#945;</span> <span class="pre">&#8594;</span> <span class="pre">list</span> <span class="pre">&#946;</span></code>, how should we define the bind operation <code class="docutils literal notranslate"><span class="pre">la</span> <span class="pre">&gt;&gt;=</span> <span class="pre">f</span></code>? Intuitively, <code class="docutils literal notranslate"><span class="pre">la</span></code> represents any of the possible values occurring in the list, and for each such element <code class="docutils literal notranslate"><span class="pre">a</span></code>, <code class="docutils literal notranslate"><span class="pre">f</span></code> may return any of the elements in <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">a</span></code>. We can then gather all the possible values of the virtual application by applying <code class="docutils literal notranslate"><span class="pre">f</span></code> to each element of <code class="docutils literal notranslate"><span class="pre">la</span></code> and merging the results into a single list:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=open%20list%0Anamespace%20hidden%0A%0A--%20BEGIN%0Adef%20bind%20%7B%CE%B1%20%CE%B2%20:%20Type%7D%20(la%20:%20list%20%CE%B1)%20(f%20:%20%CE%B1%20%E2%86%92%20list%20%CE%B2)%20:%20list%20%CE%B2%20:=%0Ajoin%20(map%20f%20la)%0A--%20END%0A%0Aend%20hidden" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kd">def</span> <span class="n">bind</span> <span class="o">{</span><span class="n">&#945;</span> <span class="n">&#946;</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">la</span> <span class="o">:</span> <span class="n">list</span> <span class="n">&#945;</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">&#945;</span> <span class="bp">&#8594;</span> <span class="n">list</span> <span class="n">&#946;</span><span class="o">)</span> <span class="o">:</span> <span class="n">list</span> <span class="n">&#946;</span> <span class="o">:=</span>
<span class="n">join</span> <span class="o">(</span><span class="n">map</span> <span class="n">f</span> <span class="n">la</span><span class="o">)</span>
</pre></div>
</div>
</div><p>Since the example in the previous section used nothing more than generic monad operations, we can replay it in the <code class="docutils literal notranslate"><span class="pre">list</span></code> setting:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=universe%20u%0Avariables%20%7B%CE%B1%20%CE%B2%20%CE%B3%20%CE%B4%20:%20Type.%7Bu%7D%7D%20(la%20:%20list%20%CE%B1)%0Avariables%20(f%20:%20%CE%B1%20%E2%86%92%20list%20%CE%B2)%20(g%20:%20%CE%B1%20%E2%86%92%20%CE%B2%20%E2%86%92%20list%20%CE%B3)%0A%20%20%20%20%20%20%20%20%20%20(h%20:%20%CE%B1%20%E2%86%92%20%CE%B2%20%E2%86%92%20%CE%B3%20%E2%86%92%20list%20%CE%B4)%0A%0Aexample%20:%20list%20%CE%B4%20:=%0Ado%20a%20%E2%86%90%20la,%0A%20%20%20b%20%E2%86%90%20f%20a,%0A%20%20%20c%20%E2%86%90%20g%20a%20b,%0A%20%20%20h%20a%20b%20c" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kd">universe</span> <span class="n">u</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">&#945;</span> <span class="n">&#946;</span> <span class="n">&#947;</span> <span class="n">&#948;</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span><span class="o">}}</span> <span class="o">(</span><span class="n">la</span> <span class="o">:</span> <span class="n">list</span> <span class="n">&#945;</span><span class="o">)</span>
<span class="kd">variables</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">&#945;</span> <span class="bp">&#8594;</span> <span class="n">list</span> <span class="n">&#946;</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">&#945;</span> <span class="bp">&#8594;</span> <span class="n">&#946;</span> <span class="bp">&#8594;</span> <span class="n">list</span> <span class="n">&#947;</span><span class="o">)</span>
          <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">&#945;</span> <span class="bp">&#8594;</span> <span class="n">&#946;</span> <span class="bp">&#8594;</span> <span class="n">&#947;</span> <span class="bp">&#8594;</span> <span class="n">list</span> <span class="n">&#948;</span><span class="o">)</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">list</span> <span class="n">&#948;</span> <span class="o">:=</span>
<span class="k">do</span> <span class="n">a</span> <span class="bp">&#8592;</span> <span class="n">la</span><span class="o">,</span>
   <span class="n">b</span> <span class="bp">&#8592;</span> <span class="n">f</span> <span class="n">a</span><span class="o">,</span>
   <span class="n">c</span> <span class="bp">&#8592;</span> <span class="n">g</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span>
   <span class="n">h</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span>
</pre></div>
</div>
</div><p>Now think of the computation as representing the list of all possible values of the expression <code class="docutils literal notranslate"><span class="pre">h</span> <span class="pre">a</span> <span class="pre">(f</span> <span class="pre">a)</span> <span class="pre">(g</span> <span class="pre">a</span> <span class="pre">(f</span> <span class="pre">a))</span></code>, where the bind percolates all possible values of the subexpressions to the final output.</p>
<p>Notice that the final output of the expression is a list, to which we can then apply any of the usual functions that deal with lists:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=open%20list%0A%0Avariables%20%7B%CE%B1%20%CE%B2%20%CE%B3%20%CE%B4%20:%20Type%7D%20(la%20:%20list%20%CE%B1)%0Avariables%20(f%20:%20%CE%B1%20%E2%86%92%20list%20%CE%B2)%20(g%20:%20%CE%B1%20%E2%86%92%20%CE%B2%20%E2%86%92%20list%20%CE%B3)%20(h%20:%20%CE%B1%20%E2%86%92%20%CE%B2%20%E2%86%92%20%CE%B3%20%E2%86%92%20list%20%CE%B4)%0A%0Aexample%20:%20%E2%84%95%20:=%0Alength%0A%20%20(do%20a%20%E2%86%90%20la,%0A%20%20%20%20%20%20b%20%E2%86%90%20f%20a,%0A%20%20%20%20%20%20c%20%E2%86%90%20g%20a%20b,%0A%20%20%20%20%20%20h%20a%20b%20c)" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kn">open</span> <span class="n">list</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">&#945;</span> <span class="n">&#946;</span> <span class="n">&#947;</span> <span class="n">&#948;</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">la</span> <span class="o">:</span> <span class="n">list</span> <span class="n">&#945;</span><span class="o">)</span>
<span class="kd">variables</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">&#945;</span> <span class="bp">&#8594;</span> <span class="n">list</span> <span class="n">&#946;</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">&#945;</span> <span class="bp">&#8594;</span> <span class="n">&#946;</span> <span class="bp">&#8594;</span> <span class="n">list</span> <span class="n">&#947;</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">&#945;</span> <span class="bp">&#8594;</span> <span class="n">&#946;</span> <span class="bp">&#8594;</span> <span class="n">&#947;</span> <span class="bp">&#8594;</span> <span class="n">list</span> <span class="n">&#948;</span><span class="o">)</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">&#8469;</span> <span class="o">:=</span>
<span class="n">length</span>
  <span class="o">(</span><span class="k">do</span> <span class="n">a</span> <span class="bp">&#8592;</span> <span class="n">la</span><span class="o">,</span>
      <span class="n">b</span> <span class="bp">&#8592;</span> <span class="n">f</span> <span class="n">a</span><span class="o">,</span>
      <span class="n">c</span> <span class="bp">&#8592;</span> <span class="n">g</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span>
      <span class="n">h</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span><span class="o">)</span>
</pre></div>
</div>
</div><p>We can also move <code class="docutils literal notranslate"><span class="pre">length</span></code> inside the <code class="docutils literal notranslate"><span class="pre">do</span></code> expression, but then the output lives in <code class="docutils literal notranslate"><span class="pre">&#8469;</span></code> instead of a <code class="docutils literal notranslate"><span class="pre">list</span></code>. As a result, we need to use <code class="docutils literal notranslate"><span class="pre">return</span></code> to put the result in a monad:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=open%20list%0A%0Avariables%20%7B%CE%B1%20%CE%B2%20%CE%B3%20%CE%B4%20:%20Type%7D%20(la%20:%20list%20%CE%B1)%0Avariables%20(f%20:%20%CE%B1%20%E2%86%92%20list%20%CE%B2)%20(g%20:%20%CE%B1%20%E2%86%92%20%CE%B2%20%E2%86%92%20list%20%CE%B3)%0A%20%20%20%20%20%20%20%20%20%20(h%20:%20%CE%B1%20%E2%86%92%20%CE%B2%20%E2%86%92%20%CE%B3%20%E2%86%92%20list%20%CE%B4)%0A%0Aexample%20:%20list%20%E2%84%95%20:=%0Ado%20a%20%E2%86%90%20la,%0A%20%20%20b%20%E2%86%90%20f%20a,%0A%20%20%20c%20%E2%86%90%20g%20a%20b,%0A%20%20%20return%20(length%20(h%20a%20b%20c))" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kn">open</span> <span class="n">list</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">&#945;</span> <span class="n">&#946;</span> <span class="n">&#947;</span> <span class="n">&#948;</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">la</span> <span class="o">:</span> <span class="n">list</span> <span class="n">&#945;</span><span class="o">)</span>
<span class="kd">variables</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">&#945;</span> <span class="bp">&#8594;</span> <span class="n">list</span> <span class="n">&#946;</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">&#945;</span> <span class="bp">&#8594;</span> <span class="n">&#946;</span> <span class="bp">&#8594;</span> <span class="n">list</span> <span class="n">&#947;</span><span class="o">)</span>
          <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">&#945;</span> <span class="bp">&#8594;</span> <span class="n">&#946;</span> <span class="bp">&#8594;</span> <span class="n">&#947;</span> <span class="bp">&#8594;</span> <span class="n">list</span> <span class="n">&#948;</span><span class="o">)</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">list</span> <span class="n">&#8469;</span> <span class="o">:=</span>
<span class="k">do</span> <span class="n">a</span> <span class="bp">&#8592;</span> <span class="n">la</span><span class="o">,</span>
   <span class="n">b</span> <span class="bp">&#8592;</span> <span class="n">f</span> <span class="n">a</span><span class="o">,</span>
   <span class="n">c</span> <span class="bp">&#8592;</span> <span class="n">g</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span>
   <span class="n">return</span> <span class="o">(</span><span class="n">length</span> <span class="o">(</span><span class="n">h</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span><span class="o">))</span>
</pre></div>
</div>
</div></div>
<div class="section" id="the-state-monad">
<h2>4.3. The state monad<a class="headerlink" href="#the-state-monad" title="Permalink to this headline">&#182;</a></h2>
<p>Let us indulge in science fiction for a moment, and suppose we wanted to extend Lean&#8217;s programming language with three global registers, <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">y</span></code>, and <code class="docutils literal notranslate"><span class="pre">z</span></code>, each of which stores a natural number. When evaluating an expression <code class="docutils literal notranslate"><span class="pre">g</span> <span class="pre">(f</span> <span class="pre">a)</span></code> with <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">:</span> <span class="pre">&#945;</span> <span class="pre">&#8594;</span> <span class="pre">&#946;</span></code> and <code class="docutils literal notranslate"><span class="pre">g</span> <span class="pre">:</span> <span class="pre">&#946;</span> <span class="pre">&#8594;</span> <span class="pre">&#947;</span></code>, <code class="docutils literal notranslate"><span class="pre">f</span></code> would start the computation with the registers initialized to <code class="docutils literal notranslate"><span class="pre">0</span></code>, but could read and write values during the course of its computation. When <code class="docutils literal notranslate"><span class="pre">g</span></code> began its computation on <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">a</span></code>, the registers would be set they way that <code class="docutils literal notranslate"><span class="pre">g</span></code> left them, and <code class="docutils literal notranslate"><span class="pre">g</span></code> could continue to read and write values. (To avoid questions as to how we would interpret the flow of control in terms like <code class="docutils literal notranslate"><span class="pre">h</span> <span class="pre">(k&#8321;</span> <span class="pre">a)</span> <span class="pre">(k&#8322;</span> <span class="pre">a)</span></code>, let us suppose that we only care about composing unary functions.)</p>
<p>There is a straightforward way to implement this behavior in a functional programming language, namely, by making the state of the three registers an explicit argument. First, let us define a data structure to hold the three values, and define the initial settings:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=structure%20registers%20:%20Type%20:=%20(x%20:%20%E2%84%95)%20(y%20:%20%E2%84%95)%20(z%20:%20%E2%84%95)%0A%0Adef%20init_reg%20:%20registers%20:=%20registers.mk%200%200%200" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kd">structure</span> <span class="n">registers</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">&#8469;</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">&#8469;</span><span class="o">)</span> <span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">&#8469;</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">init_reg</span> <span class="o">:</span> <span class="n">registers</span> <span class="o">:=</span> <span class="n">registers.mk</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span>
</pre></div>
</div>
</div><p>Now, instead of defining <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">:</span> <span class="pre">&#945;</span> <span class="pre">&#8594;</span> <span class="pre">&#946;</span></code> that operates on the state of the registers implicitly, we would define a function <code class="docutils literal notranslate"><span class="pre">f&#8320;</span> <span class="pre">:</span> <span class="pre">&#945;</span> <span class="pre">&#215;</span> <span class="pre">registers</span> <span class="pre">&#8594;</span> <span class="pre">&#946;</span> <span class="pre">&#215;</span> <span class="pre">registers</span></code> that operates on it explicitly. The function <code class="docutils literal notranslate"><span class="pre">f&#8320;</span></code> would take an input <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">:</span> <span class="pre">&#945;</span></code>, paired with the state of the registers at the beginning of the computation. It could the do whatever it wanted to the state, and return an output <code class="docutils literal notranslate"><span class="pre">b</span> <span class="pre">:</span> <span class="pre">&#946;</span></code> paired with the new state. Similarly, we would replace <code class="docutils literal notranslate"><span class="pre">g</span></code> by a function <code class="docutils literal notranslate"><span class="pre">g&#8320;</span> <span class="pre">:</span> <span class="pre">&#946;</span> <span class="pre">&#215;</span> <span class="pre">registers</span> <span class="pre">&#8594;</span> <span class="pre">&#947;</span> <span class="pre">&#215;</span> <span class="pre">registers</span></code>. The result of the composite computation would be given by <code class="docutils literal notranslate"><span class="pre">(g&#8320;</span> <span class="pre">(f&#8320;</span> <span class="pre">(a,</span> <span class="pre">init_reg))).1</span></code>. In other words, we would pair the value <code class="docutils literal notranslate"><span class="pre">a</span></code> with the initial setting of the registers, apply <code class="docutils literal notranslate"><span class="pre">f&#8320;</span></code> and then <code class="docutils literal notranslate"><span class="pre">g&#8320;</span></code>, and take the first component. If we wanted to lay our hands on the state of the registers at the end of the computation, we could do that by taking the second component.</p>
<p>The biggest problem with this approach is the annoying overhead. To write functions this way, we would have to pair and unpair arguments and construct the new state explicitly. A key virtue of the monad abstraction is that it manages boilerplate operations in situations just like these.</p>
<p>Indeed, the monadic solution is not far away. By currying the input, we could take the input of <code class="docutils literal notranslate"><span class="pre">f&#8320;</span></code> equally well to be <code class="docutils literal notranslate"><span class="pre">&#945;</span> <span class="pre">&#8594;</span> <span class="pre">registers</span> <span class="pre">&#8594;</span> <span class="pre">&#946;</span> <span class="pre">&#215;</span> <span class="pre">registers</span></code>. Now think of <code class="docutils literal notranslate"><span class="pre">f&#8320;</span></code> as being a function which takes an input in <code class="docutils literal notranslate"><span class="pre">&#945;</span></code> and returns an element of <code class="docutils literal notranslate"><span class="pre">registers</span> <span class="pre">&#8594;</span> <span class="pre">&#946;</span> <span class="pre">&#215;</span> <span class="pre">registers</span></code>. Moreover, think of this output as representing a computation which starts with a certain state, and returns a value of <code class="docutils literal notranslate"><span class="pre">&#946;</span></code> and a new state. Lo and behold, <em>that</em> is the relevant monad.</p>
<p>To be precise: for any type <code class="docutils literal notranslate"><span class="pre">&#945;</span></code>, the monad <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">&#945;</span></code> we are after is <code class="docutils literal notranslate"><span class="pre">registers</span> <span class="pre">&#8594;</span> <span class="pre">&#945;</span> <span class="pre">&#215;</span> <span class="pre">registers</span></code>. We will call this the state monad for <code class="docutils literal notranslate"><span class="pre">registers</span></code>. With this notation, the function <code class="docutils literal notranslate"><span class="pre">f&#8320;</span></code> described above has type <code class="docutils literal notranslate"><span class="pre">&#945;</span> <span class="pre">&#8594;</span> <span class="pre">m</span> <span class="pre">&#946;</span></code>, the function <code class="docutils literal notranslate"><span class="pre">g&#8320;</span></code> has type <code class="docutils literal notranslate"><span class="pre">&#946;</span> <span class="pre">&#8594;</span> <span class="pre">m</span> <span class="pre">&#947;</span></code>, and the composition of the two on input <code class="docutils literal notranslate"><span class="pre">a</span></code> is <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">a</span> <span class="pre">&gt;&gt;=</span> <span class="pre">g</span></code>. Notice that the result is an element of <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">&#947;</span></code>, which is to say, it is a computation which takes any state and returns a value of <code class="docutils literal notranslate"><span class="pre">&#947;</span></code> paired with a new state. With <code class="docutils literal notranslate"><span class="pre">do</span></code> notation, we would express this instead as <code class="docutils literal notranslate"><span class="pre">do</span> <span class="pre">b</span> <span class="pre">&#8592;</span> <span class="pre">f</span> <span class="pre">a,</span> <span class="pre">g</span> <span class="pre">b</span></code>. If we want to leave the monad and extract a value in <code class="docutils literal notranslate"><span class="pre">&#947;</span></code>, we can apply this expression to the initial state <code class="docutils literal notranslate"><span class="pre">init_reg</span></code>, and take the first element of the resulting pair.</p>
<p>The last thing to notice is that there is nothing special about <code class="docutils literal notranslate"><span class="pre">registers</span></code> here. The same trick would work for any data structure that we choose to represent the state of a computation at a given point in time. We could describe, for example, registers, a stack, a heap, or any combination of these. For every type <code class="docutils literal notranslate"><span class="pre">S</span></code>, Lean&#8217;s library defines the state monad <code class="docutils literal notranslate"><span class="pre">state</span> <span class="pre">S</span></code> to be the monad that maps any type <code class="docutils literal notranslate"><span class="pre">&#945;</span></code> to the type <code class="docutils literal notranslate"><span class="pre">S</span> <span class="pre">&#8594;</span> <span class="pre">&#945;</span> <span class="pre">&#215;</span> <span class="pre">S</span></code>. (In the Lean implementation, the data is stored in a single field of a structure.) The particular monad described above is then simply <code class="docutils literal notranslate"><span class="pre">state</span> <span class="pre">registers</span></code>.</p>
<p>Let us consider the <code class="docutils literal notranslate"><span class="pre">return</span></code> and <code class="docutils literal notranslate"><span class="pre">bind</span></code> operations. Given any <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">:</span> <span class="pre">&#945;</span></code>, <code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">a</span></code> is given by <code class="docutils literal notranslate"><span class="pre">&#955;</span> <span class="pre">s,</span> <span class="pre">(a,</span> <span class="pre">s)</span></code>. This represents the computation which takes any state <code class="docutils literal notranslate"><span class="pre">s</span></code>, leaves it unchanged, and inserts <code class="docutils literal notranslate"><span class="pre">a</span></code> as the return value. The value of <code class="docutils literal notranslate"><span class="pre">bind</span></code> is tricker. Given an <code class="docutils literal notranslate"><span class="pre">sa</span> <span class="pre">:</span> <span class="pre">state</span> <span class="pre">S</span> <span class="pre">&#945;</span></code> and an <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">:</span> <span class="pre">&#945;</span> <span class="pre">&#8594;</span> <span class="pre">state</span> <span class="pre">S</span> <span class="pre">&#946;</span></code>, remember that <code class="docutils literal notranslate"><span class="pre">bind</span> <span class="pre">sa</span> <span class="pre">f</span></code> is supposed to &#8220;reach into the box,&#8221; extract an element <code class="docutils literal notranslate"><span class="pre">a</span></code> from <code class="docutils literal notranslate"><span class="pre">sa</span></code>, and apply <code class="docutils literal notranslate"><span class="pre">f</span></code> to it inside the monad. Now, the result of <code class="docutils literal notranslate"><span class="pre">bind</span> <span class="pre">sa</span> <span class="pre">f</span></code> is supposed to be an element of <code class="docutils literal notranslate"><span class="pre">state</span> <span class="pre">S</span> <span class="pre">&#946;</span></code>, which is really a function <code class="docutils literal notranslate"><span class="pre">S</span> <span class="pre">&#8594;</span> <span class="pre">&#946;</span> <span class="pre">&#215;</span> <span class="pre">S</span></code>. In other words, <code class="docutils literal notranslate"><span class="pre">bind</span> <span class="pre">sa</span> <span class="pre">f</span></code> is supposed to encode a function which operates on any state to produce an element of <code class="docutils literal notranslate"><span class="pre">&#946;</span></code> to a new state. Doing so is straightforward: given any state <code class="docutils literal notranslate"><span class="pre">s</span></code>, <code class="docutils literal notranslate"><span class="pre">sa</span> <span class="pre">s</span></code> consists of a pair <code class="docutils literal notranslate"><span class="pre">(a,</span> <span class="pre">s&#8320;)</span></code>, and applying <code class="docutils literal notranslate"><span class="pre">f</span></code> to <code class="docutils literal notranslate"><span class="pre">a</span></code> and then <code class="docutils literal notranslate"><span class="pre">s&#8320;</span></code> yields the required element of <code class="docutils literal notranslate"><span class="pre">&#946;</span> <span class="pre">&#215;</span> <span class="pre">S</span></code>. Thus the def of <code class="docutils literal notranslate"><span class="pre">bind</span> <span class="pre">sa</span> <span class="pre">f</span></code> is as follows:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre>&#955; s, match (sa s) with (a, s&#8320;) := b a s&#8320;
</pre></div>
</div>
<p>The library also defines operations <code class="docutils literal notranslate"><span class="pre">get</span></code> and <code class="docutils literal notranslate"><span class="pre">put</span></code> as follows:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=namespace%20hidden%0A%0Adef%20get%20%7BS%20:%20Type%7D%20:%20state%20S%20S%20:=%0A%E2%9F%A8%CE%BB%20s,%20(s,%20s)%E2%9F%A9%0A%0Adef%20put%20%7BS%20:%20Type%7D%20:%20S%20%E2%86%92%20state%20S%20unit%20:=%20%CE%BB%20s%E2%82%80,%20%E2%9F%A8%CE%BB%20s,%20((),%20s%E2%82%80)%E2%9F%A9%0A%0Aend%20hidden" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kn">namespace</span> <span class="n">hidden</span>

<span class="kd">def</span> <span class="n">get</span> <span class="o">{</span><span class="n">S</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">:</span> <span class="n">state</span> <span class="n">S</span> <span class="n">S</span> <span class="o">:=</span>
<span class="o">&#10216;</span><span class="bp">&#955;</span> <span class="n">s</span><span class="o">,</span> <span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="n">s</span><span class="o">)&#10217;</span>

<span class="kd">def</span> <span class="n">put</span> <span class="o">{</span><span class="n">S</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">:</span> <span class="n">S</span> <span class="bp">&#8594;</span> <span class="n">state</span> <span class="n">S</span> <span class="n">unit</span> <span class="o">:=</span> <span class="bp">&#955;</span> <span class="n">s&#8320;</span><span class="o">,</span> <span class="o">&#10216;</span><span class="bp">&#955;</span> <span class="n">s</span><span class="o">,</span> <span class="o">((),</span> <span class="n">s&#8320;</span><span class="o">)&#10217;</span>

<span class="kd">end</span> <span class="n">hidden</span>
</pre></div>
</div>
</div><p>With the argument <code class="docutils literal notranslate"><span class="pre">S</span></code> implicit, <code class="docutils literal notranslate"><span class="pre">get</span></code> is simply the state computation that does not change the current state, but also returns it as a value. The value <code class="docutils literal notranslate"><span class="pre">put</span> <span class="pre">s&#8320;</span></code> is the state computation which replaces any state <code class="docutils literal notranslate"><span class="pre">s</span></code> by <code class="docutils literal notranslate"><span class="pre">s&#8320;</span></code> and returns <code class="docutils literal notranslate"><span class="pre">unit</span></code>. Notice that it is convenient to use <code class="docutils literal notranslate"><span class="pre">unit</span></code> for the output type any operation that does not return a value, though it may change the state.</p>
<p>Returning to our example, we can implement the register state monad and more focused get and put operations as follows:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=structure%20registers%20:%20Type%20:=%20(x%20:%20%E2%84%95)%20(y%20:%20%E2%84%95)%20(z%20:%20%E2%84%95)%0A%0A--%20BEGIN%0Adef%20init_reg%20:%20registers%20:=%0Aregisters.mk%200%200%200%0A%0A&#64;%5Breducible%5D%20def%20reg_state%20:=%20state%20registers%0A%0Adef%20get_x%20:%20reg_state%20%E2%84%95%20:=%0Ado%20s%20%E2%86%90%20get,%20return%20(registers.x%20s)%0A%0Adef%20get_y%20:%20reg_state%20%E2%84%95%20:=%0Ado%20s%20%E2%86%90%20get,%20return%20(registers.y%20s)%0A%0Adef%20get_z%20:%20reg_state%20%E2%84%95%20:=%0Ado%20s%20%E2%86%90%20get,%20return%20(registers.z%20s)%0A%0Adef%20put_x%20(n%20:%20%E2%84%95)%20:%20reg_state%20unit%20:=%0Ado%20s%20%E2%86%90%20get,%0A%20%20%20put%20(registers.mk%20n%20(registers.y%20s)%20(registers.z%20s))%0A%0Adef%20put_y%20(n%20:%20%E2%84%95)%20:%20reg_state%20unit%20:=%0Ado%20s%20%E2%86%90%20get,%0A%20%20%20put(registers.mk%20(registers.x%20s)%20n%20(registers.z%20s))%0A%0Adef%20put_z%20(n%20:%20%E2%84%95)%20:%20reg_state%20unit%20:=%0Ado%20s%20%E2%86%90%20get,%0A%20%20%20put%20(registers.mk%20(registers.x%20s)%20(registers.y%20s)%20n)%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kd">def</span> <span class="n">init_reg</span> <span class="o">:</span> <span class="n">registers</span> <span class="o">:=</span>
<span class="n">registers.mk</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span>

<span class="kd">@[reducible]</span> <span class="kd">def</span> <span class="n">reg_state</span> <span class="o">:=</span> <span class="n">state</span> <span class="n">registers</span>

<span class="kd">def</span> <span class="n">get_x</span> <span class="o">:</span> <span class="n">reg_state</span> <span class="n">&#8469;</span> <span class="o">:=</span>
<span class="k">do</span> <span class="n">s</span> <span class="bp">&#8592;</span> <span class="n">get</span><span class="o">,</span> <span class="n">return</span> <span class="o">(</span><span class="n">registers.x</span> <span class="n">s</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">get_y</span> <span class="o">:</span> <span class="n">reg_state</span> <span class="n">&#8469;</span> <span class="o">:=</span>
<span class="k">do</span> <span class="n">s</span> <span class="bp">&#8592;</span> <span class="n">get</span><span class="o">,</span> <span class="n">return</span> <span class="o">(</span><span class="n">registers.y</span> <span class="n">s</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">get_z</span> <span class="o">:</span> <span class="n">reg_state</span> <span class="n">&#8469;</span> <span class="o">:=</span>
<span class="k">do</span> <span class="n">s</span> <span class="bp">&#8592;</span> <span class="n">get</span><span class="o">,</span> <span class="n">return</span> <span class="o">(</span><span class="n">registers.z</span> <span class="n">s</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">put_x</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">&#8469;</span><span class="o">)</span> <span class="o">:</span> <span class="n">reg_state</span> <span class="n">unit</span> <span class="o">:=</span>
<span class="k">do</span> <span class="n">s</span> <span class="bp">&#8592;</span> <span class="n">get</span><span class="o">,</span>
   <span class="n">put</span> <span class="o">(</span><span class="n">registers.mk</span> <span class="n">n</span> <span class="o">(</span><span class="n">registers.y</span> <span class="n">s</span><span class="o">)</span> <span class="o">(</span><span class="n">registers.z</span> <span class="n">s</span><span class="o">))</span>

<span class="kd">def</span> <span class="n">put_y</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">&#8469;</span><span class="o">)</span> <span class="o">:</span> <span class="n">reg_state</span> <span class="n">unit</span> <span class="o">:=</span>
<span class="k">do</span> <span class="n">s</span> <span class="bp">&#8592;</span> <span class="n">get</span><span class="o">,</span>
   <span class="n">put</span><span class="o">(</span><span class="n">registers.mk</span> <span class="o">(</span><span class="n">registers.x</span> <span class="n">s</span><span class="o">)</span> <span class="n">n</span> <span class="o">(</span><span class="n">registers.z</span> <span class="n">s</span><span class="o">))</span>

<span class="kd">def</span> <span class="n">put_z</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">&#8469;</span><span class="o">)</span> <span class="o">:</span> <span class="n">reg_state</span> <span class="n">unit</span> <span class="o">:=</span>
<span class="k">do</span> <span class="n">s</span> <span class="bp">&#8592;</span> <span class="n">get</span><span class="o">,</span>
   <span class="n">put</span> <span class="o">(</span><span class="n">registers.mk</span> <span class="o">(</span><span class="n">registers.x</span> <span class="n">s</span><span class="o">)</span> <span class="o">(</span><span class="n">registers.y</span> <span class="n">s</span><span class="o">)</span> <span class="n">n</span><span class="o">)</span>
</pre></div>
</div>
</div><p>We can then write a little register program as follows:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=structure%20registers%20:%20Type%20:=%20(x%20:%20%E2%84%95)%20(y%20:%20%E2%84%95)%20(z%20:%20%E2%84%95)%0A%0Adef%20init_reg%20:%20registers%20:=%0Aregisters.mk%200%200%200%0A%0A&#64;%5Breducible%5D%20def%20reg_state%20:=%20state%20registers%0A%0Adef%20get_x%20:%20reg_state%20%E2%84%95%20:=%0Ado%20s%20%E2%86%90%20get,%20return%20(registers.x%20s)%0A%0Adef%20get_y%20:%20reg_state%20%E2%84%95%20:=%0Ado%20s%20%E2%86%90%20get,%20return%20(registers.y%20s)%0A%0Adef%20get_z%20:%20reg_state%20%E2%84%95%20:=%0Ado%20s%20%E2%86%90%20get,%20return%20(registers.z%20s)%0A%0Adef%20put_x%20(n%20:%20%E2%84%95)%20:%20reg_state%20unit%20:=%0Ado%20s%20%E2%86%90%20get,%0A%20%20%20put%20(registers.mk%20n%20(registers.y%20s)%20(registers.z%20s))%0A%0Adef%20put_y%20(n%20:%20%E2%84%95)%20:%20reg_state%20unit%20:=%0Ado%20s%20%E2%86%90%20get,%0A%20%20%20put(registers.mk%20(registers.x%20s)%20n%20(registers.z%20s))%0A%0Adef%20put_z%20(n%20:%20%E2%84%95)%20:%20reg_state%20unit%20:=%0Ado%20s%20%E2%86%90%20get,%0A%20%20%20put%20(registers.mk%20(registers.x%20s)%20(registers.y%20s)%20n)%0A%0A--%20BEGIN%0Aopen%20nat%0A%0Adef%20foo%20:%20reg_state%20%E2%84%95%20:=%0Ado%20put_x%205,%0A%20%20%20put_y%207,%0A%20%20%20x%20%E2%86%90%20get_x,%0A%20%20%20put_z%20(x%20+%203),%0A%20%20%20y%20%E2%86%90%20get_y,%0A%20%20%20z%20%E2%86%90%20get_z,%0A%20%20%20put_y%20(y%20+%20z),%0A%20%20%20y%20%E2%86%90%20get_y,%0A%20%20%20return%20(y%20+%202)%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kn">open</span> <span class="n">nat</span>

<span class="kd">def</span> <span class="n">foo</span> <span class="o">:</span> <span class="n">reg_state</span> <span class="n">&#8469;</span> <span class="o">:=</span>
<span class="k">do</span> <span class="n">put_x</span> <span class="mi">5</span><span class="o">,</span>
   <span class="n">put_y</span> <span class="mi">7</span><span class="o">,</span>
   <span class="n">x</span> <span class="bp">&#8592;</span> <span class="n">get_x</span><span class="o">,</span>
   <span class="n">put_z</span> <span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="mi">3</span><span class="o">),</span>
   <span class="n">y</span> <span class="bp">&#8592;</span> <span class="n">get_y</span><span class="o">,</span>
   <span class="n">z</span> <span class="bp">&#8592;</span> <span class="n">get_z</span><span class="o">,</span>
   <span class="n">put_y</span> <span class="o">(</span><span class="n">y</span> <span class="bp">+</span> <span class="n">z</span><span class="o">),</span>
   <span class="n">y</span> <span class="bp">&#8592;</span> <span class="n">get_y</span><span class="o">,</span>
   <span class="n">return</span> <span class="o">(</span><span class="n">y</span> <span class="bp">+</span> <span class="mi">2</span><span class="o">)</span>
</pre></div>
</div>
</div><p>To see the results of this program, we have to &#8220;run&#8221; it on the initial
state:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=structure%20registers%20:%20Type%20:=%20(x%20:%20%E2%84%95)%20(y%20:%20%E2%84%95)%20(z%20:%20%E2%84%95)%0A%0Adef%20init_reg%20:%20registers%20:=%0Aregisters.mk%200%200%200%0A%0A&#64;%5Breducible%5D%20def%20reg_state%20:=%20state%20registers%0A%0Adef%20get_x%20:%20reg_state%20%E2%84%95%20:=%0Ado%20s%20%E2%86%90%20get,%20return%20(registers.x%20s)%0A%0Adef%20get_y%20:%20reg_state%20%E2%84%95%20:=%0Ado%20s%20%E2%86%90%20get,%20return%20(registers.y%20s)%0A%0Adef%20get_z%20:%20reg_state%20%E2%84%95%20:=%0Ado%20s%20%E2%86%90%20get,%20return%20(registers.z%20s)%0A%0Adef%20put_x%20(n%20:%20%E2%84%95)%20:%20reg_state%20unit%20:=%0Ado%20s%20%E2%86%90%20get,%0A%20%20%20put%20(registers.mk%20n%20(registers.y%20s)%20(registers.z%20s))%0A%0Adef%20put_y%20(n%20:%20%E2%84%95)%20:%20reg_state%20unit%20:=%0Ado%20s%20%E2%86%90%20get,%0A%20%20%20put(registers.mk%20(registers.x%20s)%20n%20(registers.z%20s))%0A%0Adef%20put_z%20(n%20:%20%E2%84%95)%20:%20reg_state%20unit%20:=%0Ado%20s%20%E2%86%90%20get,%0A%20%20%20put%20(registers.mk%20(registers.x%20s)%20(registers.y%20s)%20n)%0A%0Aopen%20nat%0A%0Adef%20foo%20:%20reg_state%20%E2%84%95%20:=%0Ado%20put_x%205,%0A%20%20%20put_y%207,%0A%20%20%20x%20%E2%86%90%20get_x,%0A%20%20%20put_z%20(x%20+%203),%0A%20%20%20y%20%E2%86%90%20get_y,%0A%20%20%20z%20%E2%86%90%20get_z,%0A%20%20%20put_y%20(y%20+%20z),%0A%20%20%20y%20%E2%86%90%20get_y,%0A%20%20%20return%20(y%20+%202)%0A%0A--%20BEGIN%0A#reduce%20foo.run%20init_reg%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="k">#reduce</span> <span class="n">foo.run</span> <span class="n">init_reg</span>
</pre></div>
</div>
</div><p>The result is the pair <code class="docutils literal notranslate"><span class="pre">(17,</span> <span class="pre">{x</span> <span class="pre">:=</span> <span class="pre">5,</span> <span class="pre">y</span> <span class="pre">:=</span> <span class="pre">15,</span> <span class="pre">z</span> <span class="pre">:=</span> <span class="pre">8})</span></code>, consisting
of the return value, <code class="docutils literal notranslate"><span class="pre">y</span></code>, paired with the values of the three
registers.</p>
</div>
<div class="section" id="the-io-monad">
<h2>4.4. The IO monad<a class="headerlink" href="#the-io-monad" title="Permalink to this headline">&#182;</a></h2>
<p>We can finally explain how Lean handles input and output: the constant <code class="docutils literal notranslate"><span class="pre">io</span></code> is axiomatically declared to be a monad with certain supporting operations. It is a kind of state monad, but in contrast to the ones discussed in the last section, here the state is entirely opaque to Lean. You can think of the state as &#8220;the real world,&#8221; or, at least, the status of interaction with the user. Lean&#8217;s axiomatically declared constants include the following:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=import%20system.io%0Aopen%20io%0A%0A#check%20(&#64;put_str%20:%20string%20%E2%86%92%20io%20unit)%0A#check%20(&#64;get_line%20:%20io%20string)" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kn">import</span> <span class="n">system.io</span>
<span class="kn">open</span> <span class="n">io</span>

<span class="k">#check</span> <span class="o">(</span><span class="bp">@</span><span class="n">put_str</span> <span class="o">:</span> <span class="n">string</span> <span class="bp">&#8594;</span> <span class="n">io</span> <span class="n">unit</span><span class="o">)</span>
<span class="k">#check</span> <span class="o">(</span><span class="bp">@</span><span class="n">get_line</span> <span class="o">:</span> <span class="n">io</span> <span class="n">string</span><span class="o">)</span>
</pre></div>
</div>
</div><p>The expression <code class="docutils literal notranslate"><span class="pre">put_str</span> <span class="pre">s</span></code> changes the <code class="docutils literal notranslate"><span class="pre">io</span></code> state by writing <code class="docutils literal notranslate"><span class="pre">s</span></code> to output; the return type, <code class="docutils literal notranslate"><span class="pre">unit</span></code>, indicates that no meaningful value is returned. The expression <code class="docutils literal notranslate"><span class="pre">get_line</span></code>, in contrast, does not take any arguments. However you want to think of the change in <code class="docutils literal notranslate"><span class="pre">io</span></code> state, a <code class="docutils literal notranslate"><span class="pre">string</span></code> value is returned inside the monad. When we use the native virtual machine interpretation, thinking of the <code class="docutils literal notranslate"><span class="pre">io</span></code> monad as representing a state is somewhat heuristic, since within the Lean language, there is nothing that we can say about it. But when we run a Lean program, the interpreter does the right thing whenever it encounters the bind and return operations for the monad, as well as the constants above. In particular, in the example below, it ensures that the argument to <code class="docutils literal notranslate"><span class="pre">put_str</span></code> is evaluated before the output is sent to the user, and that the expressions are printed in the right order.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=import%20system.io%0Aopen%20io%0A%0A--%20BEGIN%0A#eval%20put_str%20%22hello%20%22%20%3E%3E%20put_str%20%22world!%22%20%3E%3E%20put_str%20(to_string%20(27%20*%2039))%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="k">#eval</span> <span class="n">put_str</span> <span class="s2">&quot;hello &quot;</span> <span class="bp">&gt;&gt;</span> <span class="n">put_str</span> <span class="s2">&quot;world!&quot;</span> <span class="bp">&gt;&gt;</span> <span class="n">put_str</span> <span class="o">(</span><span class="n">to_string</span> <span class="o">(</span><span class="mi">27</span> <span class="bp">*</span> <span class="mi">39</span><span class="o">))</span>
</pre></div>
</div>
</div></div>
<div class="section" id="related-type-classes">
<h2>4.5. Related type classes<a class="headerlink" href="#related-type-classes" title="Permalink to this headline">&#182;</a></h2>
<p>In addition to the monad type class, Lean defines all the following abstract type classes and notations.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=open%20monad%20function%0Auniverse%20variables%20u%20v%0A%0Anamespace%20hidden%0A%0Aclass%20functor%20(f%20:%20Type%20u%20%E2%86%92%20Type%20v)%20:%20Type%20(max%20(u+1)%20v)%20:=%0A(map%20:%20%CE%A0%20%7B%CE%B1%20%CE%B2%20:%20Type%20u%7D,%20(%CE%B1%20%E2%86%92%20%CE%B2)%20%E2%86%92%20f%20%CE%B1%20%E2%86%92%20f%20%CE%B2)%0A(map_const%20:%20%CE%A0%20%7B%CE%B1%20%CE%B2%20:%20Type%20u%7D,%20%CE%B1%20%E2%86%92%20f%20%CE%B2%20%E2%86%92%20f%20%CE%B1%20:=%20%CE%BB%20%CE%B1%20%CE%B2,%20map%20%E2%88%98%20const%20%CE%B2)%0A%0Alocal%20infixr%20%60%20%3C$%3E%20%60:100%20:=%20functor.map%0A%0Aend%20hidden%0A%0Anamespace%20hidden'%0A%0Ainfixl%20%60%20%3C*%3E%20%60:60%20:=%20has_seq.seq%0A%0Aclass%20applicative%20(f%20:%20Type%20u%20%E2%86%92%20Type%20v)%20extends%20functor%20f,%20has_pure%20f,%20has_seq%20f,%20has_seq_left%20f,%20has_seq_right%20f%20:=%0A(map%20%20%20%20%20%20%20:=%20%CE%BB%20_%20_%20x%20y,%20pure%20x%20%3C*%3E%20y)%0A(seq_left%20%20:=%20%CE%BB%20%CE%B1%20%CE%B2%20a%20b,%20const%20%CE%B2%20%3C$%3E%20a%20%3C*%3E%20b)%0A(seq_right%20:=%20%CE%BB%20%CE%B1%20%CE%B2%20a%20b,%20const%20%CE%B1%20id%20%3C$%3E%20a%20%3C*%3E%20b)%0A%0Aclass%20has_orelse%20(f%20:%20Type%20u%20%E2%86%92%20Type%20v)%20:%20Type%20(max%20(u+1)%20v)%20:=%0A(orelse%20%20:%20%CE%A0%20%7B%CE%B1%20:%20Type%20u%7D,%20f%20%CE%B1%20%E2%86%92%20f%20%CE%B1%20%E2%86%92%20f%20%CE%B1)%0A%0Ainfixr%20%60%20%3C%7C%3E%20%60:2%20:=%20has_orelse.orelse%0A%0Aend%20hidden'" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kn">open</span> <span class="n">monad</span> <span class="n">function</span>
<span class="kd">universe</span> <span class="kd">variables</span> <span class="n">u</span> <span class="n">v</span>

<span class="kn">namespace</span> <span class="n">hidden</span>

<span class="kd">class</span> <span class="n">functor</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span> <span class="bp">&#8594;</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="o">(</span><span class="n">u</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">map</span> <span class="o">:</span> <span class="bp">&#928;</span> <span class="o">{</span><span class="n">&#945;</span> <span class="n">&#946;</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">},</span> <span class="o">(</span><span class="n">&#945;</span> <span class="bp">&#8594;</span> <span class="n">&#946;</span><span class="o">)</span> <span class="bp">&#8594;</span> <span class="n">f</span> <span class="n">&#945;</span> <span class="bp">&#8594;</span> <span class="n">f</span> <span class="n">&#946;</span><span class="o">)</span>
<span class="o">(</span><span class="n">map_const</span> <span class="o">:</span> <span class="bp">&#928;</span> <span class="o">{</span><span class="n">&#945;</span> <span class="n">&#946;</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">},</span> <span class="n">&#945;</span> <span class="bp">&#8594;</span> <span class="n">f</span> <span class="n">&#946;</span> <span class="bp">&#8594;</span> <span class="n">f</span> <span class="n">&#945;</span> <span class="o">:=</span> <span class="bp">&#955;</span> <span class="n">&#945;</span> <span class="n">&#946;</span><span class="o">,</span> <span class="n">map</span> <span class="bp">&#8728;</span> <span class="n">const</span> <span class="n">&#946;</span><span class="o">)</span>

<span class="kn">local</span> <span class="kd">infixr</span> <span class="bp">`</span> <span class="bp">&lt;$&gt;</span> <span class="bp">`</span><span class="o">:</span><span class="mi">100</span> <span class="o">:=</span> <span class="n">functor.map</span>

<span class="kd">end</span> <span class="n">hidden</span>

<span class="kn">namespace</span> <span class="n">hidden&#39;</span>

<span class="kd">infixl</span> <span class="bp">`</span> <span class="bp">&lt;*&gt;</span> <span class="bp">`</span><span class="o">:</span><span class="mi">60</span> <span class="o">:=</span> <span class="n">has_seq.seq</span>

<span class="kd">class</span> <span class="n">applicative</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span> <span class="bp">&#8594;</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">functor</span> <span class="n">f</span><span class="o">,</span> <span class="n">has_pure</span> <span class="n">f</span><span class="o">,</span> <span class="n">has_seq</span> <span class="n">f</span><span class="o">,</span> <span class="n">has_seq_left</span> <span class="n">f</span><span class="o">,</span> <span class="n">has_seq_right</span> <span class="n">f</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">map</span>       <span class="o">:=</span> <span class="bp">&#955;</span> <span class="n">_</span> <span class="n">_</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">pure</span> <span class="n">x</span> <span class="bp">&lt;*&gt;</span> <span class="n">y</span><span class="o">)</span>
<span class="o">(</span><span class="n">seq_left</span>  <span class="o">:=</span> <span class="bp">&#955;</span> <span class="n">&#945;</span> <span class="n">&#946;</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">const</span> <span class="n">&#946;</span> <span class="bp">&lt;$&gt;</span> <span class="n">a</span> <span class="bp">&lt;*&gt;</span> <span class="n">b</span><span class="o">)</span>
<span class="o">(</span><span class="n">seq_right</span> <span class="o">:=</span> <span class="bp">&#955;</span> <span class="n">&#945;</span> <span class="n">&#946;</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">const</span> <span class="n">&#945;</span> <span class="n">id</span> <span class="bp">&lt;$&gt;</span> <span class="n">a</span> <span class="bp">&lt;*&gt;</span> <span class="n">b</span><span class="o">)</span>

<span class="kd">class</span> <span class="n">has_orelse</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span> <span class="bp">&#8594;</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="o">(</span><span class="n">u</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">orelse</span>  <span class="o">:</span> <span class="bp">&#928;</span> <span class="o">{</span><span class="n">&#945;</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">},</span> <span class="n">f</span> <span class="n">&#945;</span> <span class="bp">&#8594;</span> <span class="n">f</span> <span class="n">&#945;</span> <span class="bp">&#8594;</span> <span class="n">f</span> <span class="n">&#945;</span><span class="o">)</span>

<span class="kd">infixr</span> <span class="bp">`</span> <span class="bp">&lt;|&gt;</span> <span class="bp">`</span><span class="o">:</span><span class="mi">2</span> <span class="o">:=</span> <span class="n">has_orelse.orelse</span>

<span class="kd">end</span> <span class="n">hidden&#39;</span>
</pre></div>
</div>
</div><p>The <code class="docutils literal notranslate"><span class="pre">monad</span></code> class extends both <code class="docutils literal notranslate"><span class="pre">functor</span></code> and <code class="docutils literal notranslate"><span class="pre">applicative</span></code>, so both of these can be seen as even more abstract versions of <code class="docutils literal notranslate"><span class="pre">monad</span></code>. On the other hand, not every <code class="docutils literal notranslate"><span class="pre">monad</span></code> is <code class="docutils literal notranslate"><span class="pre">alternative</span></code>, and in the next chapter we will see an important example of one that is. One way to think about an alternative monad is to think of it as representing computations that can possibly fail, and, moreover, Intuitively, an alternative monad can be thought of supporting definitions that say &#8220;try <code class="docutils literal notranslate"><span class="pre">a</span></code> first, and if that doesn&#8217;t work, try <code class="docutils literal notranslate"><span class="pre">b</span></code>.&#8221; A good example is the <code class="docutils literal notranslate"><span class="pre">option</span></code> monad, in which we can think of an element <code class="docutils literal notranslate"><span class="pre">none</span></code> as a computation that has failed. If <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code> are elements of <code class="docutils literal notranslate"><span class="pre">option</span> <span class="pre">&#945;</span></code> for some type <code class="docutils literal notranslate"><span class="pre">&#945;</span></code>, we can define <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&lt;|&gt;</span> <span class="pre">b</span></code> to have the value <code class="docutils literal notranslate"><span class="pre">a</span></code> if <code class="docutils literal notranslate"><span class="pre">a</span></code> is of the form <code class="docutils literal notranslate"><span class="pre">some</span> <span class="pre">a&#8320;</span></code>, and <code class="docutils literal notranslate"><span class="pre">b</span></code> otherwise.</p>
</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">Programming in Lean</a></h1>








<!-- <h3>Navigation</h3> -->
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="introduction.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="types_and_terms.html">2. Types and Terms</a></li>
<li class="toctree-l1"><a class="reference internal" href="basic_programming.html">3. Basic Programming</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">4. Monads</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#the-option-monad">4.1. The option monad</a></li>
<li class="toctree-l2"><a class="reference internal" href="#the-list-monad">4.2. The list monad</a></li>
<li class="toctree-l2"><a class="reference internal" href="#the-state-monad">4.3. The state monad</a></li>
<li class="toctree-l2"><a class="reference internal" href="#the-io-monad">4.4. The IO monad</a></li>
<li class="toctree-l2"><a class="reference internal" href="#related-type-classes">4.5. Related type classes</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="writing_tactics.html">5. Writing Tactics</a></li>
<li class="toctree-l1"><a class="reference internal" href="writing_automation.html">6. Writing Automation</a></li>
</ul>


<hr />
<ul>
    
    <li class="toctree-l1"><a href="programming_in_lean.pdf">PDF version</a></li>
    
    <li class="toctree-l1"><a href="https://leanprover.github.io/">Lean Home</a></li>
    
</ul>

<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2017, Jeremy Avigad and Simon Hudon.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.8.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/monads.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>