
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=ascii" />
    <title>6. Writing Automation &#8212; Programming in Lean 3.4.2 documentation</title>
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/language_data.js"></script>
    <link rel="shortcut icon" href="_static/favicon.ico"/>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="5. Writing Tactics" href="writing_tactics.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="writing-automation">
<span id="id1"></span><h1>6. Writing Automation<a class="headerlink" href="#writing-automation" title="Permalink to this headline">&#182;</a></h1>
<p>The goal of this chapter is to provide some examples that illustrate the ways that metaprogramming in Lean can be used to implement automated proof procedures.</p>
<div class="section" id="a-tableau-prover-for-classical-propositional-logic">
<h2>6.1. A Tableau Prover for Classical Propositional Logic<a class="headerlink" href="#a-tableau-prover-for-classical-propositional-logic" title="Permalink to this headline">&#182;</a></h2>
<p>In this section, we design a theorem prover that is complete for classical propositional logic. The method is essentially that of tableaux theorem proving, and, from a proof-theoretic standpoint, can be used to demonstrate the completeness of cut-free sequent calculi.</p>
<p>The idea is simple. If <code class="docutils literal notranslate"><span class="pre">a</span></code>, <code class="docutils literal notranslate"><span class="pre">b</span></code>, <code class="docutils literal notranslate"><span class="pre">c</span></code>, and <code class="docutils literal notranslate"><span class="pre">d</span></code> are formulas of propositional logic, the sequent <code class="docutils literal notranslate"><span class="pre">a,</span> <span class="pre">b,</span> <span class="pre">c</span> <span class="pre">&#8866;</span> <span class="pre">d</span></code> represents the goal of proving that <code class="docutils literal notranslate"><span class="pre">d</span></code> follows from <code class="docutils literal notranslate"><span class="pre">a</span></code>, <code class="docutils literal notranslate"><span class="pre">b</span></code> and <code class="docutils literal notranslate"><span class="pre">c</span></code>, and <code class="docutils literal notranslate"><span class="pre">d</span></code>. The fact that they are propositional formulas means that they are built up from variables of type <code class="docutils literal notranslate"><span class="pre">Prop</span></code> and the constants <code class="docutils literal notranslate"><span class="pre">true</span></code> and <code class="docutils literal notranslate"><span class="pre">false</span></code> using the connectives <code class="docutils literal notranslate"><span class="pre">&#8743;</span> <span class="pre">&#8744;</span> <span class="pre">&#8594;</span> <span class="pre">&#8596;</span> <span class="pre">&#172;</span></code>. The proof procedure proceeds as follows:</p>
<ul class="simple">
<li>Negate the conclusion, so that the goal becomes <code class="docutils literal notranslate"><span class="pre">a,</span> <span class="pre">b,</span> <span class="pre">c,</span> <span class="pre">&#172;</span> <span class="pre">d</span> <span class="pre">&#8866;</span> <span class="pre">false</span></code>.</li>
<li>Put all formulas into <em>negation-normal form</em>. In other words, eliminate <code class="docutils literal notranslate"><span class="pre">&#8594;</span></code> and <code class="docutils literal notranslate"><span class="pre">&#8596;</span></code> in terms of the other connectives, and using classical identities to push all equivalences inwards.</li>
<li>At that stage, all formulas are built up from <em>literals</em> (propositional variables and negated propositional variables) using only <code class="docutils literal notranslate"><span class="pre">&#8743;</span></code> and <code class="docutils literal notranslate"><span class="pre">&#8744;</span></code>. Now repeatedly apply all of the following proof steps:<ul>
<li>Reduce a goal of the form <code class="docutils literal notranslate"><span class="pre">&#915;,</span> <span class="pre">a</span> <span class="pre">&#8743;</span> <span class="pre">b</span> <span class="pre">&#8866;</span> <span class="pre">false</span></code> to the goal <code class="docutils literal notranslate"><span class="pre">&#915;,</span> <span class="pre">a,</span> <span class="pre">b</span> <span class="pre">&#8866;</span> <span class="pre">false</span></code>, where <code class="docutils literal notranslate"><span class="pre">&#915;</span></code> is any set of propositional formulas.</li>
<li>Reduce a goal of the form <code class="docutils literal notranslate"><span class="pre">&#915;,</span> <span class="pre">a</span> <span class="pre">&#8744;</span> <span class="pre">b</span> <span class="pre">&#8866;</span> <span class="pre">false</span></code> to the pair of goals <code class="docutils literal notranslate"><span class="pre">&#915;,</span> <span class="pre">a</span> <span class="pre">&#8866;</span> <span class="pre">false</span></code> and <code class="docutils literal notranslate"><span class="pre">&#915;,</span> <span class="pre">b</span> <span class="pre">&#8866;</span> <span class="pre">false</span></code>.</li>
<li>Prove any goal of the form <code class="docutils literal notranslate"><span class="pre">&#915;,</span> <span class="pre">a,</span> <span class="pre">&#172;</span> <span class="pre">a</span> <span class="pre">&#8866;</span> <span class="pre">false</span></code> in the usual way.</li>
</ul>
</li>
</ul>
<p>It is not hard to show that this is complete. Each step preserves validity, in the sense that the original goal is provable if and only if the new ones are. And, in each step, the number of connectives in the goal decreases. If we ever face a goal in which the first two rules do not apply, the goal must consist of literals. In that case, if the last rule doesn&#8217;t apply, then no propositional variable appears with its negation, and it is easy to cook up a truth assignment that falsifies the goal.</p>
<p>In fact, our procedure will work with arbitrary formulas at the leaves. It simply applies reductions and rules as much as possible, so formulas that begin with anything other than a propositional connective are treated as black boxes, and act as propositional atoms.</p>
<p>First, let us open the namespaces we will use:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=open%20expr%20tactic%20classical" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kn">open</span> <span class="n">expr</span> <span class="n">tactic</span> <span class="n">classical</span>
</pre></div>
</div>
</div><p>The next step is to gather all the facts we will need to put formulas in negation-normal form.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=open%20expr%20tactic%20classical%0A%0A--%20BEGIN%0Asection%20logical_equivalences%0A%20%20local%20attribute%20%5Binstance%5D%20prop_decidable%0A%20%20variables%20%7Ba%20b%20:%20Prop%7D%0A%0A%20%20theorem%20not_not_iff%20(a%20:%20Prop)%20:%20%C2%AC%C2%ACa%20%E2%86%94%20a%20:=%0A%20%20iff.intro%20classical.by_contradiction%20not_not_intro%0A%0A%20%20theorem%20implies_iff_not_or%20(a%20b%20:%20Prop)%20:%20(a%20%E2%86%92%20b)%20%E2%86%94%20(%C2%AC%20a%20%E2%88%A8%20b)%20:=%0A%20%20iff.intro%0A%20%20%20%20(%CE%BB%20h,%20if%20ha%20:%20a%20then%20or.inr%20(h%20ha)%20else%20or.inl%20ha)%0A%20%20%20%20(%CE%BB%20h,%20or.elim%20h%20(%CE%BB%20hna%20ha,%20absurd%20ha%20hna)%20(%CE%BB%20hb%20ha,%20hb))%0A%0A%20%20theorem%20not_and_of_not_or_not%20(h%20:%20%C2%AC%20a%20%E2%88%A8%20%C2%AC%20b)%20:%20%C2%AC%20(a%20%E2%88%A7%20b)%20:=%0A%20%20assume%20%E2%9F%A8ha,%20hb%E2%9F%A9,%20or.elim%20h%20(assume%20hna,%20hna%20ha)%20(assume%20hnb,%20hnb%20hb)%0A%0A%20%20theorem%20not_or_not_of_not_and%20(h%20:%20%C2%AC%20(a%20%E2%88%A7%20b))%20:%20%C2%AC%20a%20%E2%88%A8%20%C2%AC%20b%20:=%0A%20%20if%20ha%20:%20a%20then%0A%20%20%20%20or.inr%20(show%20%C2%AC%20b,%20from%20assume%20hb,%20h%20%E2%9F%A8ha,%20hb%E2%9F%A9)%0A%20%20else%0A%20%20%20%20or.inl%20ha%0A%0A%20%20theorem%20not_and_iff%20(a%20b%20:%20Prop)%20:%20%C2%AC%20(a%20%E2%88%A7%20b)%20%E2%86%94%20%C2%ACa%20%E2%88%A8%20%C2%ACb%20:=%0A%20%20iff.intro%20not_or_not_of_not_and%20not_and_of_not_or_not%0A%0A%20%20theorem%20not_or_of_not_and_not%20(h%20:%20%C2%AC%20a%20%E2%88%A7%20%C2%AC%20b)%20:%20%C2%AC%20(a%20%E2%88%A8%20b)%20:=%0A%20%20assume%20h%E2%82%81,%20or.elim%20h%E2%82%81%20(assume%20ha,%20h%5E.left%20ha)%20(assume%20hb,%20h%5E.right%20hb)%0A%0A%20%20theorem%20not_and_not_of_not_or%20(h%20:%20%C2%AC%20(a%20%E2%88%A8%20b))%20:%20%C2%AC%20a%20%E2%88%A7%20%C2%AC%20b%20:=%0A%20%20and.intro%20(assume%20ha,%20h%20(or.inl%20ha))%20(assume%20hb,%20h%20(or.inr%20hb))%0A%0A%20%20theorem%20not_or_iff%20(a%20b%20:%20Prop)%20:%20%C2%AC%20(a%20%E2%88%A8%20b)%20%E2%86%94%20%C2%AC%20a%20%E2%88%A7%20%C2%AC%20b%20:=%0A%20%20iff.intro%20not_and_not_of_not_or%20not_or_of_not_and_not%0Aend%20logical_equivalences%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kn">section</span> <span class="n">logical_equivalences</span>
  <span class="kn">local</span> <span class="kn">attribute</span> <span class="o">[</span><span class="kd">instance</span><span class="o">]</span> <span class="n">prop_decidable</span>
  <span class="kd">variables</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">}</span>

  <span class="kd">theorem</span> <span class="n">not_not_iff</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="bp">&#172;&#172;</span><span class="n">a</span> <span class="bp">&#8596;</span> <span class="n">a</span> <span class="o">:=</span>
  <span class="n">iff.intro</span> <span class="n">classical.by_contradiction</span> <span class="n">not_not_intro</span>

  <span class="kd">theorem</span> <span class="n">implies_iff_not_or</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">a</span> <span class="bp">&#8594;</span> <span class="n">b</span><span class="o">)</span> <span class="bp">&#8596;</span> <span class="o">(</span><span class="bp">&#172;</span> <span class="n">a</span> <span class="bp">&#8744;</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span>
  <span class="n">iff.intro</span>
    <span class="o">(</span><span class="bp">&#955;</span> <span class="n">h</span><span class="o">,</span> <span class="k">if</span> <span class="n">ha</span> <span class="o">:</span> <span class="n">a</span> <span class="k">then</span> <span class="n">or.inr</span> <span class="o">(</span><span class="n">h</span> <span class="n">ha</span><span class="o">)</span> <span class="k">else</span> <span class="n">or.inl</span> <span class="n">ha</span><span class="o">)</span>
    <span class="o">(</span><span class="bp">&#955;</span> <span class="n">h</span><span class="o">,</span> <span class="n">or.elim</span> <span class="n">h</span> <span class="o">(</span><span class="bp">&#955;</span> <span class="n">hna</span> <span class="n">ha</span><span class="o">,</span> <span class="n">absurd</span> <span class="n">ha</span> <span class="n">hna</span><span class="o">)</span> <span class="o">(</span><span class="bp">&#955;</span> <span class="n">hb</span> <span class="n">ha</span><span class="o">,</span> <span class="n">hb</span><span class="o">))</span>

  <span class="kd">theorem</span> <span class="n">not_and_of_not_or_not</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">&#172;</span> <span class="n">a</span> <span class="bp">&#8744;</span> <span class="bp">&#172;</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="bp">&#172;</span> <span class="o">(</span><span class="n">a</span> <span class="bp">&#8743;</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span>
  <span class="k">assume</span> <span class="o">&#10216;</span><span class="n">ha</span><span class="o">,</span> <span class="n">hb</span><span class="o">&#10217;,</span> <span class="n">or.elim</span> <span class="n">h</span> <span class="o">(</span><span class="k">assume</span> <span class="n">hna</span><span class="o">,</span> <span class="n">hna</span> <span class="n">ha</span><span class="o">)</span> <span class="o">(</span><span class="k">assume</span> <span class="n">hnb</span><span class="o">,</span> <span class="n">hnb</span> <span class="n">hb</span><span class="o">)</span>

  <span class="kd">theorem</span> <span class="n">not_or_not_of_not_and</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">&#172;</span> <span class="o">(</span><span class="n">a</span> <span class="bp">&#8743;</span> <span class="n">b</span><span class="o">))</span> <span class="o">:</span> <span class="bp">&#172;</span> <span class="n">a</span> <span class="bp">&#8744;</span> <span class="bp">&#172;</span> <span class="n">b</span> <span class="o">:=</span>
  <span class="k">if</span> <span class="n">ha</span> <span class="o">:</span> <span class="n">a</span> <span class="k">then</span>
    <span class="n">or.inr</span> <span class="o">(</span><span class="k">show</span> <span class="bp">&#172;</span> <span class="n">b</span><span class="o">,</span> <span class="k">from</span> <span class="k">assume</span> <span class="n">hb</span><span class="o">,</span> <span class="n">h</span> <span class="o">&#10216;</span><span class="n">ha</span><span class="o">,</span> <span class="n">hb</span><span class="o">&#10217;)</span>
  <span class="k">else</span>
    <span class="n">or.inl</span> <span class="n">ha</span>

  <span class="kd">theorem</span> <span class="n">not_and_iff</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="bp">&#172;</span> <span class="o">(</span><span class="n">a</span> <span class="bp">&#8743;</span> <span class="n">b</span><span class="o">)</span> <span class="bp">&#8596;</span> <span class="bp">&#172;</span><span class="n">a</span> <span class="bp">&#8744;</span> <span class="bp">&#172;</span><span class="n">b</span> <span class="o">:=</span>
  <span class="n">iff.intro</span> <span class="n">not_or_not_of_not_and</span> <span class="n">not_and_of_not_or_not</span>

  <span class="kd">theorem</span> <span class="n">not_or_of_not_and_not</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">&#172;</span> <span class="n">a</span> <span class="bp">&#8743;</span> <span class="bp">&#172;</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="bp">&#172;</span> <span class="o">(</span><span class="n">a</span> <span class="bp">&#8744;</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span>
  <span class="k">assume</span> <span class="n">h&#8321;</span><span class="o">,</span> <span class="n">or.elim</span> <span class="n">h&#8321;</span> <span class="o">(</span><span class="k">assume</span> <span class="n">ha</span><span class="o">,</span> <span class="n">h</span><span class="bp">^.</span><span class="n">left</span> <span class="n">ha</span><span class="o">)</span> <span class="o">(</span><span class="k">assume</span> <span class="n">hb</span><span class="o">,</span> <span class="n">h</span><span class="bp">^.</span><span class="n">right</span> <span class="n">hb</span><span class="o">)</span>

  <span class="kd">theorem</span> <span class="n">not_and_not_of_not_or</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">&#172;</span> <span class="o">(</span><span class="n">a</span> <span class="bp">&#8744;</span> <span class="n">b</span><span class="o">))</span> <span class="o">:</span> <span class="bp">&#172;</span> <span class="n">a</span> <span class="bp">&#8743;</span> <span class="bp">&#172;</span> <span class="n">b</span> <span class="o">:=</span>
  <span class="n">and.intro</span> <span class="o">(</span><span class="k">assume</span> <span class="n">ha</span><span class="o">,</span> <span class="n">h</span> <span class="o">(</span><span class="n">or.inl</span> <span class="n">ha</span><span class="o">))</span> <span class="o">(</span><span class="k">assume</span> <span class="n">hb</span><span class="o">,</span> <span class="n">h</span> <span class="o">(</span><span class="n">or.inr</span> <span class="n">hb</span><span class="o">))</span>

  <span class="kd">theorem</span> <span class="n">not_or_iff</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="bp">&#172;</span> <span class="o">(</span><span class="n">a</span> <span class="bp">&#8744;</span> <span class="n">b</span><span class="o">)</span> <span class="bp">&#8596;</span> <span class="bp">&#172;</span> <span class="n">a</span> <span class="bp">&#8743;</span> <span class="bp">&#172;</span> <span class="n">b</span> <span class="o">:=</span>
  <span class="n">iff.intro</span> <span class="n">not_and_not_of_not_or</span> <span class="n">not_or_of_not_and_not</span>
<span class="kd">end</span> <span class="n">logical_equivalences</span>
</pre></div>
</div>
</div><p>We can now use Lean&#8217;s built-in simplifier to do the normalization:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=open%20expr%20tactic%20classical%0A%0Asection%20logical_equivalences%0A%20%20local%20attribute%20%5Binstance%5D%20prop_decidable%0A%20%20variables%20%7Ba%20b%20:%20Prop%7D%0A%0A%20%20theorem%20not_not_iff%20(a%20:%20Prop)%20:%20%C2%AC%C2%ACa%20%E2%86%94%20a%20:=%0A%20%20iff.intro%20classical.by_contradiction%20not_not_intro.%0A%0A%20%20theorem%20implies_iff_not_or%20(a%20b%20:%20Prop)%20:%20(a%20%E2%86%92%20b)%20%E2%86%94%20(%C2%AC%20a%20%E2%88%A8%20b)%20:=%0A%20%20iff.intro%0A%20%20%20%20(%CE%BB%20h,%20if%20ha%20:%20a%20then%20or.inr%20(h%20ha)%20else%20or.inl%20ha)%0A%20%20%20%20(%CE%BB%20h,%20or.elim%20h%20(%CE%BB%20hna%20ha,%20absurd%20ha%20hna)%20(%CE%BB%20hb%20ha,%20hb))%0A%0A%20%20theorem%20not_and_of_not_or_not%20(h%20:%20%C2%AC%20a%20%E2%88%A8%20%C2%AC%20b)%20:%20%C2%AC%20(a%20%E2%88%A7%20b)%20:=%0A%20%20assume%20%E2%9F%A8ha,%20hb%E2%9F%A9,%20or.elim%20h%20(assume%20hna,%20hna%20ha)%20(assume%20hnb,%20hnb%20hb)%0A%0A%20%20theorem%20not_or_not_of_not_and%20(h%20:%20%C2%AC%20(a%20%E2%88%A7%20b))%20:%20%C2%AC%20a%20%E2%88%A8%20%C2%AC%20b%20:=%0A%20%20if%20ha%20:%20a%20then%0A%20%20%20%20or.inr%20(show%20%C2%AC%20b,%20from%20assume%20hb,%20h%20%E2%9F%A8ha,%20hb%E2%9F%A9)%0A%20%20else%0A%20%20%20%20or.inl%20ha%0A%0A%20%20theorem%20not_and_iff%20(a%20b%20:%20Prop)%20:%20%C2%AC%20(a%20%E2%88%A7%20b)%20%E2%86%94%20%C2%ACa%20%E2%88%A8%20%C2%ACb%20:=%0A%20%20iff.intro%20not_or_not_of_not_and%20not_and_of_not_or_not%0A%0A%20%20theorem%20not_or_of_not_and_not%20(h%20:%20%C2%AC%20a%20%E2%88%A7%20%C2%AC%20b)%20:%20%C2%AC%20(a%20%E2%88%A8%20b)%20:=%0A%20%20assume%20h%E2%82%81,%20or.elim%20h%E2%82%81%20(assume%20ha,%20h%5E.left%20ha)%20(assume%20hb,%20h%5E.right%20hb)%0A%0A%20%20theorem%20not_and_not_of_not_or%20(h%20:%20%C2%AC%20(a%20%E2%88%A8%20b))%20:%20%C2%AC%20a%20%E2%88%A7%20%C2%AC%20b%20:=%0A%20%20and.intro%20(assume%20ha,%20h%20(or.inl%20ha))%20(assume%20hb,%20h%20(or.inr%20hb))%0A%0A%20%20theorem%20not_or_iff%20(a%20b%20:%20Prop)%20:%20%C2%AC%20(a%20%E2%88%A8%20b)%20%E2%86%94%20%C2%AC%20a%20%E2%88%A7%20%C2%AC%20b%20:=%0A%20%20iff.intro%20not_and_not_of_not_or%20not_or_of_not_and_not%0Aend%20logical_equivalences%0A%0A--%20BEGIN%0Ameta%20def%20normalize_hyp%20(lemmas%20:%20simp_lemmas)%20(hyp%20:%20expr)%20:%20tactic%20unit%20:=%0Ado%20try%20(simp_hyp%20lemmas%20%5B%5D%20hyp)%0A%0Ameta%20def%20normalize_hyps%20:%20tactic%20unit%20:=%0Ado%20hyps%20%E2%86%90%20local_context,%0A%20%20%20lemmas%20%E2%86%90%20(monad.mapm%20mk_const%20%5B%60%60iff_iff_implies_and_implies,%0A%20%20%20%20%20%20%20%20%20%60%60implies_iff_not_or,%20%60%60not_and_iff,%20%60%60not_or_iff,%20%60%60not_not_iff,%0A%20%20%20%20%20%20%20%20%20%60%60not_true_iff,%20%60%60not_false_iff%5D%20%3E%3E=%20simp_lemmas.mk.append),%0A%20%20%20monad.mapm'%20(normalize_hyp%20lemmas)%20hyps%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kd">meta</span> <span class="kd">def</span> <span class="n">normalize_hyp</span> <span class="o">(</span><span class="n">lemmas</span> <span class="o">:</span> <span class="n">simp_lemmas</span><span class="o">)</span> <span class="o">(</span><span class="n">hyp</span> <span class="o">:</span> <span class="n">expr</span><span class="o">)</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span>
<span class="k">do</span> <span class="n">try</span> <span class="o">(</span><span class="n">simp_hyp</span> <span class="n">lemmas</span> <span class="o">[]</span> <span class="n">hyp</span><span class="o">)</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">normalize_hyps</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span>
<span class="k">do</span> <span class="n">hyps</span> <span class="bp">&#8592;</span> <span class="n">local_context</span><span class="o">,</span>
   <span class="n">lemmas</span> <span class="bp">&#8592;</span> <span class="o">(</span><span class="n">monad.mapm</span> <span class="n">mk_const</span> <span class="o">[</span><span class="bp">``</span><span class="n">iff_iff_implies_and_implies</span><span class="o">,</span>
         <span class="bp">``</span><span class="n">implies_iff_not_or</span><span class="o">,</span> <span class="bp">``</span><span class="n">not_and_iff</span><span class="o">,</span> <span class="bp">``</span><span class="n">not_or_iff</span><span class="o">,</span> <span class="bp">``</span><span class="n">not_not_iff</span><span class="o">,</span>
         <span class="bp">``</span><span class="n">not_true_iff</span><span class="o">,</span> <span class="bp">``</span><span class="n">not_false_iff</span><span class="o">]</span> <span class="bp">&gt;&gt;=</span> <span class="n">simp_lemmas.mk.append</span><span class="o">),</span>
   <span class="n">monad.mapm&#39;</span> <span class="o">(</span><span class="n">normalize_hyp</span> <span class="n">lemmas</span><span class="o">)</span> <span class="n">hyps</span>
</pre></div>
</div>
</div><p>The tactic <code class="docutils literal notranslate"><span class="pre">normalize_hyp</span></code> just simplifies the given hypothesis with the given list of lemmas. The <code class="docutils literal notranslate"><span class="pre">try</span></code> combinator ensures that the tactic is deemed successful even if no simplifications are necessary. The tactic <code class="docutils literal notranslate"><span class="pre">normalize_hyps</span></code> gathers the local context, turns the list of names into a list of expressions by applying the <code class="docutils literal notranslate"><span class="pre">mk_const</span></code> tactic to each one, and then calls <code class="docutils literal notranslate"><span class="pre">normalize_hyp</span></code> on each element of the context with those lemmas. The <code class="docutils literal notranslate"><span class="pre">for</span></code>&#8217; tactic, like the <code class="docutils literal notranslate"><span class="pre">for</span></code> tactic, applies the second argument to each element of the first, but it returns unit rather than accumulate the results in a list.</p>
<p>We can test the result:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=open%20expr%20tactic%20classical%0A%0Asection%20logical_equivalences%0A%20%20local%20attribute%20%5Binstance%5D%20prop_decidable%0A%20%20variables%20%7Ba%20b%20:%20Prop%7D%0A%0A%20%20theorem%20not_not_iff%20(a%20:%20Prop)%20:%20%C2%AC%C2%ACa%20%E2%86%94%20a%20:=%0A%20%20iff.intro%20classical.by_contradiction%20not_not_intro.%0A%0A%20%20theorem%20implies_iff_not_or%20(a%20b%20:%20Prop)%20:%20(a%20%E2%86%92%20b)%20%E2%86%94%20(%C2%AC%20a%20%E2%88%A8%20b)%20:=%0A%20%20iff.intro%0A%20%20%20%20(%CE%BB%20h,%20if%20ha%20:%20a%20then%20or.inr%20(h%20ha)%20else%20or.inl%20ha)%0A%20%20%20%20(%CE%BB%20h,%20or.elim%20h%20(%CE%BB%20hna%20ha,%20absurd%20ha%20hna)%20(%CE%BB%20hb%20ha,%20hb))%0A%0A%20%20theorem%20not_and_of_not_or_not%20(h%20:%20%C2%AC%20a%20%E2%88%A8%20%C2%AC%20b)%20:%20%C2%AC%20(a%20%E2%88%A7%20b)%20:=%0A%20%20assume%20%E2%9F%A8ha,%20hb%E2%9F%A9,%20or.elim%20h%20(assume%20hna,%20hna%20ha)%20(assume%20hnb,%20hnb%20hb)%0A%0A%20%20theorem%20not_or_not_of_not_and%20(h%20:%20%C2%AC%20(a%20%E2%88%A7%20b))%20:%20%C2%AC%20a%20%E2%88%A8%20%C2%AC%20b%20:=%0A%20%20if%20ha%20:%20a%20then%0A%20%20%20%20or.inr%20(show%20%C2%AC%20b,%20from%20assume%20hb,%20h%20%E2%9F%A8ha,%20hb%E2%9F%A9)%0A%20%20else%0A%20%20%20%20or.inl%20ha%0A%0A%20%20theorem%20not_and_iff%20(a%20b%20:%20Prop)%20:%20%C2%AC%20(a%20%E2%88%A7%20b)%20%E2%86%94%20%C2%ACa%20%E2%88%A8%20%C2%ACb%20:=%0A%20%20iff.intro%20not_or_not_of_not_and%20not_and_of_not_or_not%0A%0A%20%20theorem%20not_or_of_not_and_not%20(h%20:%20%C2%AC%20a%20%E2%88%A7%20%C2%AC%20b)%20:%20%C2%AC%20(a%20%E2%88%A8%20b)%20:=%0A%20%20assume%20h%E2%82%81,%20or.elim%20h%E2%82%81%20(assume%20ha,%20h%5E.left%20ha)%20(assume%20hb,%20h%5E.right%20hb)%0A%0A%20%20theorem%20not_and_not_of_not_or%20(h%20:%20%C2%AC%20(a%20%E2%88%A8%20b))%20:%20%C2%AC%20a%20%E2%88%A7%20%C2%AC%20b%20:=%0A%20%20and.intro%20(assume%20ha,%20h%20(or.inl%20ha))%20(assume%20hb,%20h%20(or.inr%20hb))%0A%0A%20%20theorem%20not_or_iff%20(a%20b%20:%20Prop)%20:%20%C2%AC%20(a%20%E2%88%A8%20b)%20%E2%86%94%20%C2%AC%20a%20%E2%88%A7%20%C2%AC%20b%20:=%0A%20%20iff.intro%20not_and_not_of_not_or%20not_or_of_not_and_not%0Aend%20logical_equivalences%0A%0Ameta%20def%20normalize_hyp%20(lemmas%20:%20simp_lemmas)%20(hyp%20:%20expr)%20:%20tactic%20unit%20:=%0Ado%20try%20(simp_hyp%20lemmas%20%5B%5D%20hyp)%0A%0Ameta%20def%20normalize_hyps%20:%20tactic%20unit%20:=%0Ado%20hyps%20%E2%86%90%20local_context,%0A%20%20%20lemmas%20%E2%86%90%20(monad.mapm%20mk_const%20%5B%60%60iff_iff_implies_and_implies,%0A%20%20%20%20%20%20%20%20%20%60%60implies_iff_not_or,%20%60%60not_and_iff,%20%60%60not_or_iff,%20%60%60not_not_iff,%0A%20%20%20%20%20%20%20%20%20%60%60not_true_iff,%20%60%60not_false_iff%5D%20%3E%3E=%20simp_lemmas.mk.append),%0A%20%20%20monad.mapm'%20(normalize_hyp%20lemmas)%20hyps%0A%0A--%20BEGIN%0Aexample%20(p%20q%20r%20:%20Prop)%20(h%E2%82%81%20:%20%C2%AC%20(p%20%E2%86%94%20(q%20%E2%88%A7%20%C2%AC%20r)))%20(h%E2%82%82%20:%20%C2%AC%20(p%20%E2%86%92%20(q%20%E2%86%92%20%C2%AC%20r)))%20:%20true%20:=%0Aby%20do%20normalize_hyps,%0A%20%20%20%20%20%20trace_state,%0A%20%20%20%20%20%20triv%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kd">example</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="n">r</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">h&#8321;</span> <span class="o">:</span> <span class="bp">&#172;</span> <span class="o">(</span><span class="n">p</span> <span class="bp">&#8596;</span> <span class="o">(</span><span class="n">q</span> <span class="bp">&#8743;</span> <span class="bp">&#172;</span> <span class="n">r</span><span class="o">)))</span> <span class="o">(</span><span class="n">h&#8322;</span> <span class="o">:</span> <span class="bp">&#172;</span> <span class="o">(</span><span class="n">p</span> <span class="bp">&#8594;</span> <span class="o">(</span><span class="n">q</span> <span class="bp">&#8594;</span> <span class="bp">&#172;</span> <span class="n">r</span><span class="o">)))</span> <span class="o">:</span> <span class="n">true</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="k">do</span> <span class="n">normalize_hyps</span><span class="o">,</span>
      <span class="n">trace_state</span><span class="o">,</span>
      <span class="n">triv</span>
</pre></div>
</div>
</div><p>The result is as follows:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre>p q r : Prop,
h&#8321; : p &#8743; (r &#8744; &#172;q) &#8744; q &#8743; &#172;p &#8743; &#172;r,
h&#8322; : p &#8743; q &#8743; r
&#8866; true
</pre></div>
</div>
<p>The next five tactics handle the task of splitting conjunctions.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=open%20tactic%20expr%0A%0Ameta%20def%20add_fact%20(prf%20:%20expr)%20:%20tactic%20unit%20:=%0Ado%20nh%20%E2%86%90%20get_unused_name%20%60h%20none,%0A%20%20%20p%20%E2%86%90%20infer_type%20prf,%0A%20%20%20assertv%20nh%20p%20prf,%0A%20%20%20return%20()%0A%0Ameta%20def%20is_conj%20(e%20:%20expr)%20:%20tactic%20bool%20:=%0Ado%20t%20%E2%86%90%20infer_type%20e,%0A%20%20%20return%20(is_app_of%20t%20%60and)%0A%0Ameta%20def%20add_conjuncts%20:%20expr%20%E2%86%92%20tactic%20unit%20%7C%20e%20:=%0Ado%20e%E2%82%81%20%E2%86%90%20mk_app%20%60and.left%20%5Be%5D,%0A%20%20%20monad.cond%20(is_conj%20e%E2%82%81)%20(add_conjuncts%20e%E2%82%81)%20(add_fact%20e%E2%82%81),%0A%20%20%20e%E2%82%82%20%E2%86%90%20mk_app%20%60and.right%20%5Be%5D,%0A%20%20%20monad.cond%20(is_conj%20e%E2%82%82)%20(add_conjuncts%20e%E2%82%82)%20(add_fact%20e%E2%82%82)%0A%0Ameta%20def%20split_conjs_at%20(h%20:%20expr)%20:%20tactic%20unit%20:=%0Ado%20monad.cond%20(is_conj%20h)%0A%20%20%20%20%20(add_conjuncts%20h%20%3E%3E%20clear%20h)%0A%20%20%20%20%20skip%0A%0Ameta%20def%20split_conjs%20:%20tactic%20unit%20:=%0Ado%20l%20%E2%86%90%20local_context,%0A%20%20%20monad.mapm'%20split_conjs_at%20l" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kn">open</span> <span class="n">tactic</span> <span class="n">expr</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">add_fact</span> <span class="o">(</span><span class="n">prf</span> <span class="o">:</span> <span class="n">expr</span><span class="o">)</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span>
<span class="k">do</span> <span class="n">nh</span> <span class="bp">&#8592;</span> <span class="n">get_unused_name</span> <span class="bp">`</span><span class="n">h</span> <span class="n">none</span><span class="o">,</span>
   <span class="n">p</span> <span class="bp">&#8592;</span> <span class="n">infer_type</span> <span class="n">prf</span><span class="o">,</span>
   <span class="n">assertv</span> <span class="n">nh</span> <span class="n">p</span> <span class="n">prf</span><span class="o">,</span>
   <span class="n">return</span> <span class="o">()</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">is_conj</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">expr</span><span class="o">)</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">bool</span> <span class="o">:=</span>
<span class="k">do</span> <span class="n">t</span> <span class="bp">&#8592;</span> <span class="n">infer_type</span> <span class="n">e</span><span class="o">,</span>
   <span class="n">return</span> <span class="o">(</span><span class="n">is_app_of</span> <span class="n">t</span> <span class="bp">`</span><span class="n">and</span><span class="o">)</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">add_conjuncts</span> <span class="o">:</span> <span class="n">expr</span> <span class="bp">&#8594;</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="bp">|</span> <span class="n">e</span> <span class="o">:=</span>
<span class="k">do</span> <span class="n">e&#8321;</span> <span class="bp">&#8592;</span> <span class="n">mk_app</span> <span class="bp">`</span><span class="n">and.left</span> <span class="o">[</span><span class="n">e</span><span class="o">],</span>
   <span class="n">monad.cond</span> <span class="o">(</span><span class="n">is_conj</span> <span class="n">e&#8321;</span><span class="o">)</span> <span class="o">(</span><span class="n">add_conjuncts</span> <span class="n">e&#8321;</span><span class="o">)</span> <span class="o">(</span><span class="n">add_fact</span> <span class="n">e&#8321;</span><span class="o">),</span>
   <span class="n">e&#8322;</span> <span class="bp">&#8592;</span> <span class="n">mk_app</span> <span class="bp">`</span><span class="n">and.right</span> <span class="o">[</span><span class="n">e</span><span class="o">],</span>
   <span class="n">monad.cond</span> <span class="o">(</span><span class="n">is_conj</span> <span class="n">e&#8322;</span><span class="o">)</span> <span class="o">(</span><span class="n">add_conjuncts</span> <span class="n">e&#8322;</span><span class="o">)</span> <span class="o">(</span><span class="n">add_fact</span> <span class="n">e&#8322;</span><span class="o">)</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">split_conjs_at</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">expr</span><span class="o">)</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span>
<span class="k">do</span> <span class="n">monad.cond</span> <span class="o">(</span><span class="n">is_conj</span> <span class="n">h</span><span class="o">)</span>
     <span class="o">(</span><span class="n">add_conjuncts</span> <span class="n">h</span> <span class="bp">&gt;&gt;</span> <span class="n">clear</span> <span class="n">h</span><span class="o">)</span>
     <span class="n">skip</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">split_conjs</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span>
<span class="k">do</span> <span class="n">l</span> <span class="bp">&#8592;</span> <span class="n">local_context</span><span class="o">,</span>
   <span class="n">monad.mapm&#39;</span> <span class="n">split_conjs_at</span> <span class="n">l</span>
</pre></div>
</div>
</div><p>The tactic <code class="docutils literal notranslate"><span class="pre">add_fact</span> <span class="pre">prf</span></code> takes a proof of a proposition <code class="docutils literal notranslate"><span class="pre">p</span></code>, and adds <code class="docutils literal notranslate"><span class="pre">p</span></code> the the local context with a fresh name. Here, <code class="docutils literal notranslate"><span class="pre">get_unused_name</span> <span class="pre">\`h</span> <span class="pre">none</span></code> generates a fresh name of the form <code class="docutils literal notranslate"><span class="pre">h_n</span></code>, for a numeral <code class="docutils literal notranslate"><span class="pre">n</span></code>. The tactic <code class="docutils literal notranslate"><span class="pre">is_conj</span></code> infers the type of a given expression, and determines whether or not it is a conjunction. The tactic <code class="docutils literal notranslate"><span class="pre">add_conjuncts</span> <span class="pre">e</span></code> assumes that the type of <code class="docutils literal notranslate"><span class="pre">e</span></code> is a conjunction and adds proofs of the left and right conjuncts to the context, recursively splitting them if they are conjuncts as well. The tactic <code class="docutils literal notranslate"><span class="pre">split_conjs_at</span> <span class="pre">h</span></code> tests whether or not the hypothesis <code class="docutils literal notranslate"><span class="pre">h</span></code> is a conjunction, and, if so, adds all its conjuncts and then clears it from the context. The last tactic, <code class="docutils literal notranslate"><span class="pre">split_conjs</span></code>, applies this to every element of the context.</p>
<p>We need two more small tactics before we can write our propositional prover. The first reduces the task of proving a statement <code class="docutils literal notranslate"><span class="pre">p</span></code> from some hypotheses to the task of proving falsity from those hypotheses and the negation of <code class="docutils literal notranslate"><span class="pre">p</span></code>.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=open%20tactic%20expr%0A%0A--%20BEGIN%0Ameta%20def%20deny_conclusion%20:%20tactic%20unit%20:=%0Ado%20refine%20%60%60%60(classical.by_contradiction%20_),%0A%20%20%20nh%20%E2%86%90%20get_unused_name%20%60h%20none,%0A%20%20%20intro%20nh,%0A%20%20%20return%20()%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kd">meta</span> <span class="kd">def</span> <span class="n">deny_conclusion</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span>
<span class="k">do</span> <span class="n">refine</span> <span class="bp">```</span><span class="o">(</span><span class="n">classical.by_contradiction</span> <span class="n">_</span><span class="o">),</span>
   <span class="n">nh</span> <span class="bp">&#8592;</span> <span class="n">get_unused_name</span> <span class="bp">`</span><span class="n">h</span> <span class="n">none</span><span class="o">,</span>
   <span class="n">intro</span> <span class="n">nh</span><span class="o">,</span>
   <span class="n">return</span> <span class="o">()</span>
</pre></div>
</div>
</div><p>The refine tactic applies the expression in question to the goal, but leaves any remaining metavariables for us to fill. The theorem <code class="docutils literal notranslate"><span class="pre">classical.by_contradiction</span></code> has type <code class="docutils literal notranslate"><span class="pre">&#8704;</span> <span class="pre">{p</span> <span class="pre">:</span> <span class="pre">Prop},</span> <span class="pre">(&#172;p</span> <span class="pre">&#8594;</span> <span class="pre">false)</span> <span class="pre">&#8594;</span> <span class="pre">p</span></code>, so applying this theorem proves the goal but leaves us with the new goal of proving <code class="docutils literal notranslate"><span class="pre">&#172;p</span> <span class="pre">&#8594;</span> <span class="pre">false</span></code> from the same hypotheses, at which point, we can use the introduction rule for implication. If we omit the <code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">()</span></code>, we will get an error message, because <code class="docutils literal notranslate"><span class="pre">deny_conclusion</span></code> is supposed to have type <code class="docutils literal notranslate"><span class="pre">tactic</span> <span class="pre">unit</span></code>, but the <code class="docutils literal notranslate"><span class="pre">intro</span></code> tactic returns an expression.</p>
<p>The next tactic finds a disjunction among the hypotheses, or returns the <code class="docutils literal notranslate"><span class="pre">option.none</span></code> if there aren&#8217;t any.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=open%20tactic%20expr%0A%0A--%20BEGIN%0Ameta%20def%20find_disj%20:%20tactic%20(option%20expr)%20:=%0Ado%20l%20%E2%86%90%20local_context,%0A%20%20%20(first%20$%20l.map%0A%20%20%20%20%20(%CE%BB%20h,%20do%20t%20%E2%86%90%20infer_type%20h,%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20cond%20(is_app_of%20t%20%60or)%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20(return%20(option.some%20h))%20failed))%20%3C%7C%3E%0A%20%20%20return%20none%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kd">meta</span> <span class="kd">def</span> <span class="n">find_disj</span> <span class="o">:</span> <span class="n">tactic</span> <span class="o">(</span><span class="n">option</span> <span class="n">expr</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">do</span> <span class="n">l</span> <span class="bp">&#8592;</span> <span class="n">local_context</span><span class="o">,</span>
   <span class="o">(</span><span class="n">first</span> <span class="bp">$</span> <span class="n">l.map</span>
     <span class="o">(</span><span class="bp">&#955;</span> <span class="n">h</span><span class="o">,</span> <span class="k">do</span> <span class="n">t</span> <span class="bp">&#8592;</span> <span class="n">infer_type</span> <span class="n">h</span><span class="o">,</span>
              <span class="n">cond</span> <span class="o">(</span><span class="n">is_app_of</span> <span class="n">t</span> <span class="bp">`</span><span class="n">or</span><span class="o">)</span>
                <span class="o">(</span><span class="n">return</span> <span class="o">(</span><span class="n">option.some</span> <span class="n">h</span><span class="o">))</span> <span class="n">failed</span><span class="o">))</span> <span class="bp">&lt;|&gt;</span>
   <span class="n">return</span> <span class="n">none</span>
</pre></div>
</div>
</div><p>Our propositional prover can now be implemented as follows:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=open%20expr%20tactic%20classical%0A%0Asection%20logical_equivalences%0A%20%20local%20attribute%20%5Binstance%5D%20prop_decidable%0A%20%20variables%20%7Ba%20b%20:%20Prop%7D%0A%0A%20%20theorem%20not_not_iff%20(a%20:%20Prop)%20:%20%C2%AC%C2%ACa%20%E2%86%94%20a%20:=%0A%20%20iff.intro%20classical.by_contradiction%20not_not_intro.%0A%0A%20%20theorem%20implies_iff_not_or%20(a%20b%20:%20Prop)%20:%20(a%20%E2%86%92%20b)%20%E2%86%94%20(%C2%AC%20a%20%E2%88%A8%20b)%20:=%0A%20%20iff.intro%0A%20%20%20%20(%CE%BB%20h,%20if%20ha%20:%20a%20then%20or.inr%20(h%20ha)%20else%20or.inl%20ha)%0A%20%20%20%20(%CE%BB%20h,%20or.elim%20h%20(%CE%BB%20hna%20ha,%20absurd%20ha%20hna)%20(%CE%BB%20hb%20ha,%20hb))%0A%0A%20%20theorem%20not_and_of_not_or_not%20(h%20:%20%C2%AC%20a%20%E2%88%A8%20%C2%AC%20b)%20:%20%C2%AC%20(a%20%E2%88%A7%20b)%20:=%0A%20%20assume%20%E2%9F%A8ha,%20hb%E2%9F%A9,%20or.elim%20h%20(assume%20hna,%20hna%20ha)%20(assume%20hnb,%20hnb%20hb)%0A%0A%20%20theorem%20not_or_not_of_not_and%20(h%20:%20%C2%AC%20(a%20%E2%88%A7%20b))%20:%20%C2%AC%20a%20%E2%88%A8%20%C2%AC%20b%20:=%0A%20%20if%20ha%20:%20a%20then%0A%20%20%20%20or.inr%20(show%20%C2%AC%20b,%20from%20assume%20hb,%20h%20%E2%9F%A8ha,%20hb%E2%9F%A9)%0A%20%20else%0A%20%20%20%20or.inl%20ha%0A%0A%20%20theorem%20not_and_iff%20(a%20b%20:%20Prop)%20:%20%C2%AC%20(a%20%E2%88%A7%20b)%20%E2%86%94%20%C2%ACa%20%E2%88%A8%20%C2%ACb%20:=%0A%20%20iff.intro%20not_or_not_of_not_and%20not_and_of_not_or_not%0A%0A%20%20theorem%20not_or_of_not_and_not%20(h%20:%20%C2%AC%20a%20%E2%88%A7%20%C2%AC%20b)%20:%20%C2%AC%20(a%20%E2%88%A8%20b)%20:=%0A%20%20assume%20h%E2%82%81,%20or.elim%20h%E2%82%81%20(assume%20ha,%20h%5E.left%20ha)%20(assume%20hb,%20h%5E.right%20hb)%0A%0A%20%20theorem%20not_and_not_of_not_or%20(h%20:%20%C2%AC%20(a%20%E2%88%A8%20b))%20:%20%C2%AC%20a%20%E2%88%A7%20%C2%AC%20b%20:=%0A%20%20and.intro%20(assume%20ha,%20h%20(or.inl%20ha))%20(assume%20hb,%20h%20(or.inr%20hb))%0A%0A%20%20theorem%20not_or_iff%20(a%20b%20:%20Prop)%20:%20%C2%AC%20(a%20%E2%88%A8%20b)%20%E2%86%94%20%C2%AC%20a%20%E2%88%A7%20%C2%AC%20b%20:=%0A%20%20iff.intro%20not_and_not_of_not_or%20not_or_of_not_and_not%0Aend%20logical_equivalences%0A%0Ameta%20def%20normalize_hyp%20(lemmas%20:%20simp_lemmas)%20(hyp%20:%20expr)%20:%20tactic%20unit%20:=%0Ado%20try%20(simp_hyp%20lemmas%20%5B%5D%20hyp)%0A%0Ameta%20def%20normalize_hyps%20:%20tactic%20unit%20:=%0Ado%20hyps%20%E2%86%90%20local_context,%0A%20%20%20lemmas%20%E2%86%90%20(monad.mapm%20mk_const%20%5B%60%60iff_iff_implies_and_implies,%0A%20%20%20%20%20%20%20%20%20%60%60implies_iff_not_or,%20%60%60not_and_iff,%20%60%60not_or_iff,%20%60%60not_not_iff,%0A%20%20%20%20%20%20%20%20%20%60%60not_true_iff,%20%60%60not_false_iff%5D%20%3E%3E=%20simp_lemmas.mk.append),%0A%20%20%20monad.mapm'%20(normalize_hyp%20lemmas)%20hyps%0A%0Ameta%20def%20add_fact%20(prf%20:%20expr)%20:%20tactic%20unit%20:=%0Ado%20nh%20%E2%86%90%20get_unused_name%20%60h%20none,%0A%20%20%20p%20%E2%86%90%20infer_type%20prf,%0A%20%20%20assertv%20nh%20p%20prf,%0A%20%20%20return%20()%0A%0Ameta%20def%20is_conj%20(e%20:%20expr)%20:%20tactic%20bool%20:=%0Ado%20t%20%E2%86%90%20infer_type%20e,%0A%20%20%20return%20(is_app_of%20t%20%60and)%0A%0Ameta%20def%20add_conjuncts%20:%20expr%20%E2%86%92%20tactic%20unit%20%7C%20e%20:=%0Ado%20e%E2%82%81%20%E2%86%90%20mk_app%20%60and.left%20%5Be%5D,%0A%20%20%20monad.cond%20(is_conj%20e%E2%82%81)%20(add_conjuncts%20e%E2%82%81)%20(add_fact%20e%E2%82%81),%0A%20%20%20e%E2%82%82%20%E2%86%90%20mk_app%20%60and.right%20%5Be%5D,%0A%20%20%20monad.cond%20(is_conj%20e%E2%82%82)%20(add_conjuncts%20e%E2%82%82)%20(add_fact%20e%E2%82%82)%0A%0Ameta%20def%20split_conjs_at%20(h%20:%20expr)%20:%20tactic%20unit%20:=%0Ado%20monad.cond%20(is_conj%20h)%0A%20%20%20%20%20(add_conjuncts%20h%20%3E%3E%20clear%20h)%0A%20%20%20%20%20skip%0A%0Ameta%20def%20split_conjs%20:%20tactic%20unit%20:=%0Ado%20l%20%E2%86%90%20local_context,%0A%20%20%20monad.mapm'%20split_conjs_at%20l%0A%0Ameta%20def%20deny_conclusion%20:%20tactic%20unit%20:=%0Ado%20refine%20%60%60%60(classical.by_contradiction%20_),%0A%20%20%20nh%20%E2%86%90%20get_unused_name%20%60h%20none,%0A%20%20%20intro%20nh,%0A%20%20%20return%20()%0A%0Ameta%20def%20find_disj%20:%20tactic%20(option%20expr)%20:=%0Ado%20l%20%E2%86%90%20local_context,%0A%20%20%20(first%20$%20l.map%0A%20%20%20%20%20(%CE%BB%20h,%20do%20t%20%E2%86%90%20infer_type%20h,%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20cond%20(is_app_of%20t%20%60or)%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20(return%20(option.some%20h))%20failed))%20%3C%7C%3E%0A%20%20%20return%20none%0A%0A--%20BEGIN%0Ameta%20def%20prop_prover_aux%20:%20%E2%84%95%20%E2%86%92%20tactic%20unit%0A%7C%200%20%20%20%20%20%20%20%20%20%20%20%20:=%20%20fail%20%22prop%20prover%20max%20depth%20reached%22%0A%7C%20(nat.succ%20n)%20:=%0A%20%20do%20split_conjs,%0A%20%20%20%20%20contradiction%20%3C%7C%3E%0A%20%20%20%20%20do%20(option.some%20h)%20%E2%86%90%20find_disj%20%7C%0A%20%20%20%20%20%20%20%20%20%20fail%20%22prop_prover%20failed:%20unprovable%20goal%22,%0A%20%20%20%20%20%20%20%20cases%20h,%0A%20%20%20%20%20%20%20%20prop_prover_aux%20n,%0A%20%20%20%20%20%20%20%20prop_prover_aux%20n%0A%0Ameta%20def%20prop_prover%20:%20tactic%20unit%20:=%0Ado%20deny_conclusion,%0A%20%20%20normalize_hyps,%0A%20%20%20prop_prover_aux%2030%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kd">meta</span> <span class="kd">def</span> <span class="n">prop_prover_aux</span> <span class="o">:</span> <span class="n">&#8469;</span> <span class="bp">&#8594;</span> <span class="n">tactic</span> <span class="n">unit</span>
<span class="bp">|</span> <span class="mi">0</span>            <span class="o">:=</span>  <span class="n">fail</span> <span class="s2">&quot;prop prover max depth reached&quot;</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">nat.succ</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span>
  <span class="k">do</span> <span class="n">split_conjs</span><span class="o">,</span>
     <span class="n">contradiction</span> <span class="bp">&lt;|&gt;</span>
     <span class="k">do</span> <span class="o">(</span><span class="n">option.some</span> <span class="n">h</span><span class="o">)</span> <span class="bp">&#8592;</span> <span class="n">find_disj</span> <span class="bp">|</span>
          <span class="n">fail</span> <span class="s2">&quot;prop_prover failed: unprovable goal&quot;</span><span class="o">,</span>
        <span class="n">cases</span> <span class="n">h</span><span class="o">,</span>
        <span class="n">prop_prover_aux</span> <span class="n">n</span><span class="o">,</span>
        <span class="n">prop_prover_aux</span> <span class="n">n</span>

<span class="kd">meta</span> <span class="kd">def</span> <span class="n">prop_prover</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span>
<span class="k">do</span> <span class="n">deny_conclusion</span><span class="o">,</span>
   <span class="n">normalize_hyps</span><span class="o">,</span>
   <span class="n">prop_prover_aux</span> <span class="mi">30</span>
</pre></div>
</div>
</div><p>The tactic <code class="docutils literal notranslate"><span class="pre">prop_prover</span></code> denies the conclusion, reduces the hypotheses to negation-normal form, and calls <code class="docutils literal notranslate"><span class="pre">prop_prover_aux</span></code> with a maximum splitting depth of 30. The tactic <code class="docutils literal notranslate"><span class="pre">prop_prover_aux</span></code> executes the following simple loop. First, it splits any conjunctions in the hypotheses. Then it tries applying the <code class="docutils literal notranslate"><span class="pre">contradiction</span></code> tactic, which will find a pair of contradictory literals, <code class="docutils literal notranslate"><span class="pre">p</span></code> and <code class="docutils literal notranslate"><span class="pre">&#172;</span> <span class="pre">p</span></code>, if there is one. If that does not succeed, it looks for a disjunction <code class="docutils literal notranslate"><span class="pre">h</span></code> among the hypotheses. At this stage, if there aren&#8217;t any disjunctions, we know that the goal is not propositionally valid. On the other hand, if there is a disjunction, <code class="docutils literal notranslate"><span class="pre">prop_prover_aux</span></code> calls the <code class="docutils literal notranslate"><span class="pre">cases</span></code> tactic to split the disjunction, and then applies itself recursively to each of the resulting subgoals, decreasing the splitting depth by one.</p>
<p>Notice the pattern matching in the <code class="docutils literal notranslate"><span class="pre">do</span></code> notation:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre>(option.some h) &#8592; find_disj |
          fail &quot;prop_prover failed: unprovable goal&quot;
</pre></div>
</div>
<p>This is shorthand for the use of the <code class="docutils literal notranslate"><span class="pre">bind</span></code> operation in the tactic monad to extract the result of <code class="docutils literal notranslate"><span class="pre">find_disj</span></code>, together with the use of a <code class="docutils literal notranslate"><span class="pre">match</span></code> statement to extract the result. The expression after the vertical bar is the value returned for any other case in the pattern match; in this case, it is the value returned if <code class="docutils literal notranslate"><span class="pre">find_disj</span></code> returns <code class="docutils literal notranslate"><span class="pre">none</span></code>. This is a common idiom when writing tactics, and so the compressed notation is handy.</p>
<p>All this is left for us to do is to try it out:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.4.1/#code=open%20expr%20tactic%20classical%0A%0Asection%20logical_equivalences%0A%20%20local%20attribute%20%5Binstance%5D%20prop_decidable%0A%20%20variables%20%7Ba%20b%20:%20Prop%7D%0A%0A%20%20theorem%20not_not_iff%20(a%20:%20Prop)%20:%20%C2%AC%C2%ACa%20%E2%86%94%20a%20:=%0A%20%20iff.intro%20classical.by_contradiction%20not_not_intro.%0A%0A%20%20theorem%20implies_iff_not_or%20(a%20b%20:%20Prop)%20:%20(a%20%E2%86%92%20b)%20%E2%86%94%20(%C2%AC%20a%20%E2%88%A8%20b)%20:=%0A%20%20iff.intro%0A%20%20%20%20(%CE%BB%20h,%20if%20ha%20:%20a%20then%20or.inr%20(h%20ha)%20else%20or.inl%20ha)%0A%20%20%20%20(%CE%BB%20h,%20or.elim%20h%20(%CE%BB%20hna%20ha,%20absurd%20ha%20hna)%20(%CE%BB%20hb%20ha,%20hb))%0A%0A%20%20theorem%20not_and_of_not_or_not%20(h%20:%20%C2%AC%20a%20%E2%88%A8%20%C2%AC%20b)%20:%20%C2%AC%20(a%20%E2%88%A7%20b)%20:=%0A%20%20assume%20%E2%9F%A8ha,%20hb%E2%9F%A9,%20or.elim%20h%20(assume%20hna,%20hna%20ha)%20(assume%20hnb,%20hnb%20hb)%0A%0A%20%20theorem%20not_or_not_of_not_and%20(h%20:%20%C2%AC%20(a%20%E2%88%A7%20b))%20:%20%C2%AC%20a%20%E2%88%A8%20%C2%AC%20b%20:=%0A%20%20if%20ha%20:%20a%20then%0A%20%20%20%20or.inr%20(show%20%C2%AC%20b,%20from%20assume%20hb,%20h%20%E2%9F%A8ha,%20hb%E2%9F%A9)%0A%20%20else%0A%20%20%20%20or.inl%20ha%0A%0A%20%20theorem%20not_and_iff%20(a%20b%20:%20Prop)%20:%20%C2%AC%20(a%20%E2%88%A7%20b)%20%E2%86%94%20%C2%ACa%20%E2%88%A8%20%C2%ACb%20:=%0A%20%20iff.intro%20not_or_not_of_not_and%20not_and_of_not_or_not%0A%0A%20%20theorem%20not_or_of_not_and_not%20(h%20:%20%C2%AC%20a%20%E2%88%A7%20%C2%AC%20b)%20:%20%C2%AC%20(a%20%E2%88%A8%20b)%20:=%0A%20%20assume%20h%E2%82%81,%20or.elim%20h%E2%82%81%20(assume%20ha,%20h%5E.left%20ha)%20(assume%20hb,%20h%5E.right%20hb)%0A%0A%20%20theorem%20not_and_not_of_not_or%20(h%20:%20%C2%AC%20(a%20%E2%88%A8%20b))%20:%20%C2%AC%20a%20%E2%88%A7%20%C2%AC%20b%20:=%0A%20%20and.intro%20(assume%20ha,%20h%20(or.inl%20ha))%20(assume%20hb,%20h%20(or.inr%20hb))%0A%0A%20%20theorem%20not_or_iff%20(a%20b%20:%20Prop)%20:%20%C2%AC%20(a%20%E2%88%A8%20b)%20%E2%86%94%20%C2%AC%20a%20%E2%88%A7%20%C2%AC%20b%20:=%0A%20%20iff.intro%20not_and_not_of_not_or%20not_or_of_not_and_not%0Aend%20logical_equivalences%0A%0Ameta%20def%20normalize_hyp%20(lemmas%20:%20simp_lemmas)%20(hyp%20:%20expr)%20:%20tactic%20unit%20:=%0Ado%20try%20(simp_hyp%20lemmas%20%5B%5D%20hyp)%0A%0Ameta%20def%20normalize_hyps%20:%20tactic%20unit%20:=%0Ado%20hyps%20%E2%86%90%20local_context,%0A%20%20%20lemmas%20%E2%86%90%20(monad.mapm%20mk_const%20%5B%60%60iff_iff_implies_and_implies,%0A%20%20%20%20%20%20%20%20%20%60%60implies_iff_not_or,%20%60%60not_and_iff,%20%60%60not_or_iff,%20%60%60not_not_iff,%0A%20%20%20%20%20%20%20%20%20%60%60not_true_iff,%20%60%60not_false_iff%5D%20%3E%3E=%20simp_lemmas.mk.append),%0A%20%20%20monad.mapm'%20(normalize_hyp%20lemmas)%20hyps%0A%0Ameta%20def%20add_fact%20(prf%20:%20expr)%20:%20tactic%20unit%20:=%0Ado%20nh%20%E2%86%90%20get_unused_name%20%60h%20none,%0A%20%20%20p%20%E2%86%90%20infer_type%20prf,%0A%20%20%20assertv%20nh%20p%20prf,%0A%20%20%20return%20()%0A%0Ameta%20def%20is_conj%20(e%20:%20expr)%20:%20tactic%20bool%20:=%0Ado%20t%20%E2%86%90%20infer_type%20e,%0A%20%20%20return%20(is_app_of%20t%20%60and)%0A%0Ameta%20def%20add_conjuncts%20:%20expr%20%E2%86%92%20tactic%20unit%20%7C%20e%20:=%0Ado%20e%E2%82%81%20%E2%86%90%20mk_app%20%60and.left%20%5Be%5D,%0A%20%20%20monad.cond%20(is_conj%20e%E2%82%81)%20(add_conjuncts%20e%E2%82%81)%20(add_fact%20e%E2%82%81),%0A%20%20%20e%E2%82%82%20%E2%86%90%20mk_app%20%60and.right%20%5Be%5D,%0A%20%20%20monad.cond%20(is_conj%20e%E2%82%82)%20(add_conjuncts%20e%E2%82%82)%20(add_fact%20e%E2%82%82)%0A%0Ameta%20def%20split_conjs_at%20(h%20:%20expr)%20:%20tactic%20unit%20:=%0Ado%20monad.cond%20(is_conj%20h)%0A%20%20%20%20%20(add_conjuncts%20h%20%3E%3E%20clear%20h)%0A%20%20%20%20%20skip%0A%0Ameta%20def%20split_conjs%20:%20tactic%20unit%20:=%0Ado%20l%20%E2%86%90%20local_context,%0A%20%20%20monad.mapm'%20split_conjs_at%20l%0A%0Ameta%20def%20deny_conclusion%20:%20tactic%20unit%20:=%0Ado%20refine%20%60%60%60(classical.by_contradiction%20_),%0A%20%20%20nh%20%E2%86%90%20get_unused_name%20%60h%20none,%0A%20%20%20intro%20nh,%0A%20%20%20return%20()%0A%0Ameta%20def%20find_disj%20:%20tactic%20(option%20expr)%20:=%0Ado%20l%20%E2%86%90%20local_context,%0A%20%20%20(first%20$%20l.map%0A%20%20%20%20%20(%CE%BB%20h,%20do%20t%20%E2%86%90%20infer_type%20h,%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20cond%20(is_app_of%20t%20%60or)%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20(return%20(option.some%20h))%20failed))%20%3C%7C%3E%0A%20%20%20return%20none%0A%0Ameta%20def%20prop_prover_aux%20:%20%E2%84%95%20%E2%86%92%20tactic%20unit%0A%7C%200%20%20%20%20%20%20%20%20%20%20%20%20:=%20%20fail%20%22prop%20prover%20max%20depth%20reached%22%0A%7C%20(nat.succ%20n)%20:=%0A%20%20do%20split_conjs,%0A%20%20%20%20%20contradiction%20%3C%7C%3E%0A%20%20%20%20%20do%20(option.some%20h)%20%E2%86%90%20find_disj%20%7C%0A%20%20%20%20%20%20%20%20%20%20fail%20%22prop_prover%20failed:%20unprovable%20goal%22,%0A%20%20%20%20%20%20%20%20cases%20h,%0A%20%20%20%20%20%20%20%20prop_prover_aux%20n,%0A%20%20%20%20%20%20%20%20prop_prover_aux%20n%0A%0Ameta%20def%20prop_prover%20:%20tactic%20unit%20:=%0Ado%20deny_conclusion,%0A%20%20%20normalize_hyps,%0A%20%20%20prop_prover_aux%2030%0A%0A--%20BEGIN%0Asection%0A%20%20variables%20a%20b%20c%20d%20:%20Prop%0A%0A%20%20example%20(h%E2%82%81%20:%20a%20%E2%88%A7%20b)%20(h%E2%82%82%20:%20b%20%E2%88%A7%20%C2%AC%20c)%20:%20a%20%E2%88%A8%20c%20:=%0A%20%20by%20prop_prover%0A%0A%20%20example%20(h%E2%82%81%20:%20a%20%E2%88%A7%20b)%20(h%E2%82%82%20:%20b%20%E2%88%A7%20%C2%AC%20c)%20:%20a%20%E2%88%A7%20%C2%AC%20c%20:=%0A%20%20by%20prop_prover%0A%0A%20%20--%20not%20valid%0A%20%20--%20example%20(h%E2%82%81%20:%20a%20%E2%88%A7%20b)%20(h%E2%82%82%20:%20b%20%E2%88%A7%20%C2%AC%20c)%20:%20a%20%E2%88%A7%20c%20:=%0A%20%20--%20by%20prop_prover%0A%0A%20%20example%20:%20((a%20%E2%86%92%20b)%20%E2%86%92%20a)%20%E2%86%92%20a%20:=%0A%20%20by%20prop_prover%0A%0A%20%20example%20:%20(a%20%E2%86%92%20b)%20%E2%88%A7%20(b%20%E2%86%92%20c)%20%E2%86%92%20a%20%E2%86%92%20c%20:=%0A%20%20by%20prop_prover%0A%0A%20%20example%20(%CE%B1%20:%20Type)%20(x%20y%20z%20w%20:%20%CE%B1)%20:%0A%20%20%20%20x%20=%20y%20%E2%88%A7%20(x%20=%20y%20%E2%86%92%20z%20=%20w)%20%E2%86%92%20z%20=%20w%20:=%0A%20%20by%20prop_prover%0A%0A%20%20example%20:%20%C2%AC%20(a%20%E2%86%94%20%C2%AC%20a)%20:=%0A%20%20by%20prop_prover%0Aend%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kn">section</span>
  <span class="kd">variables</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">d</span> <span class="o">:</span> <span class="kt">Prop</span>

  <span class="kd">example</span> <span class="o">(</span><span class="n">h&#8321;</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">&#8743;</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">h&#8322;</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">&#8743;</span> <span class="bp">&#172;</span> <span class="n">c</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">&#8744;</span> <span class="n">c</span> <span class="o">:=</span>
  <span class="kd">by</span> <span class="n">prop_prover</span>

  <span class="kd">example</span> <span class="o">(</span><span class="n">h&#8321;</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">&#8743;</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">h&#8322;</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">&#8743;</span> <span class="bp">&#172;</span> <span class="n">c</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">&#8743;</span> <span class="bp">&#172;</span> <span class="n">c</span> <span class="o">:=</span>
  <span class="kd">by</span> <span class="n">prop_prover</span>

  <span class="c1">-- not valid</span>
  <span class="c1">-- example (h&#8321; : a &#8743; b) (h&#8322; : b &#8743; &#172; c) : a &#8743; c :=</span>
  <span class="c1">-- by prop_prover</span>

  <span class="kd">example</span> <span class="o">:</span> <span class="o">((</span><span class="n">a</span> <span class="bp">&#8594;</span> <span class="n">b</span><span class="o">)</span> <span class="bp">&#8594;</span> <span class="n">a</span><span class="o">)</span> <span class="bp">&#8594;</span> <span class="n">a</span> <span class="o">:=</span>
  <span class="kd">by</span> <span class="n">prop_prover</span>

  <span class="kd">example</span> <span class="o">:</span> <span class="o">(</span><span class="n">a</span> <span class="bp">&#8594;</span> <span class="n">b</span><span class="o">)</span> <span class="bp">&#8743;</span> <span class="o">(</span><span class="n">b</span> <span class="bp">&#8594;</span> <span class="n">c</span><span class="o">)</span> <span class="bp">&#8594;</span> <span class="n">a</span> <span class="bp">&#8594;</span> <span class="n">c</span> <span class="o">:=</span>
  <span class="kd">by</span> <span class="n">prop_prover</span>

  <span class="kd">example</span> <span class="o">(</span><span class="n">&#945;</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="n">w</span> <span class="o">:</span> <span class="n">&#945;</span><span class="o">)</span> <span class="o">:</span>
    <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="bp">&#8743;</span> <span class="o">(</span><span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="bp">&#8594;</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">w</span><span class="o">)</span> <span class="bp">&#8594;</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">w</span> <span class="o">:=</span>
  <span class="kd">by</span> <span class="n">prop_prover</span>

  <span class="kd">example</span> <span class="o">:</span> <span class="bp">&#172;</span> <span class="o">(</span><span class="n">a</span> <span class="bp">&#8596;</span> <span class="bp">&#172;</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span>
  <span class="kd">by</span> <span class="n">prop_prover</span>
<span class="kd">end</span>
</pre></div>
</div>
</div></div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">Programming in Lean</a></h1>








<!-- <h3>Navigation</h3> -->
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="introduction.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="types_and_terms.html">2. Types and Terms</a></li>
<li class="toctree-l1"><a class="reference internal" href="basic_programming.html">3. Basic Programming</a></li>
<li class="toctree-l1"><a class="reference internal" href="monads.html">4. Monads</a></li>
<li class="toctree-l1"><a class="reference internal" href="writing_tactics.html">5. Writing Tactics</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">6. Writing Automation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#a-tableau-prover-for-classical-propositional-logic">6.1. A Tableau Prover for Classical Propositional Logic</a></li>
</ul>
</li>
</ul>


<hr />
<ul>
    
    <li class="toctree-l1"><a href="programming_in_lean.pdf">PDF version</a></li>
    
    <li class="toctree-l1"><a href="https://leanprover.github.io/">Lean Home</a></li>
    
</ul>

<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2017, Jeremy Avigad and Simon Hudon.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.8.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/writing_automation.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>